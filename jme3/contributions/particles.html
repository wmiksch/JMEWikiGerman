<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><title>Next Generation Particle Emitters</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"><link rel="stylesheet" href="/home/travis/build/wmiksch/JMEWikiGerman/build/asciidoc/html5/jme3/contributions/twemoji-awesome.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/wmiksch/JMEWikiGerman/edit/master/src/docs/asciidoc/jme3/contributions/particles.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/wmiksch/JMEWikiGerman/new/master/src/docs/asciidoc/jme3/contributions/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>Next Generation Particle Emitters</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Inhaltsverzeichnis</div><ul class="sectlevel1"><li><a href="#credits">Credits</a></li><li><a href="#the-big-picture">The Big Picture</a></li><li><a href="#simple-fire">Simple Fire</a></li><li><a href="#simple-fire-and-smoke">Simple Fire and Smoke</a></li><li><a href="#quad-meshes-and-billboarding">Quad Meshes and Billboarding</a></li><li><a href="#using-a-mesh-as-the-particle-source">Using a mesh as the particle source</a></li><li><a href="#meshes-and-weighted-meshes">Meshes and Weighted Meshes</a></li><li><a href="#3d-particles-templatemesh">3d Particles - TemplateMesh</a></li><li><a href="#emitting-particles-from-particles">Emitting Particles from Particles</a></li></ul></div></div><div id="content"><div id="preamble"><div class="sectionbody"><div class="paragraph"><p>This is a new particle system for jME3 posted for review and comments. This is an opportunity for people to comment on and request changes to the <abbr title="Application Programming Interface">API</abbr> or the internal functionality of the system.
The code for this particle system can be found <a href="https://github.com/jMonkeyEngine-Contributions/ParticleController">jMonkeyEngine-Contributions</a></p></div>
<div class="paragraph"><p>Apologies for the slight jitter in some of the videos, the VideoRecorderState seems to be causing some issues which are not present when the application is running normally.</p></div></div></div>
<div class="sect1"><h2 id="credits">Credits</h2><div class="sectionbody"><div class="paragraph"><p>These particle emitters are inspired by and use some code from t0neg0ds particle emitters as described <a href="http://hub.jmonkeyengine.org/t/influencer-based-particleemitter-candidate-mesh-based-animated-particles/25831">here</a></p></div>
<div class="paragraph"><p>Those in turn were based on the original jME3 particle system by Kirill Vainer</p></div></div></div>
<div class="sect1"><h2 id="the-big-picture">The Big Picture</h2><div class="sectionbody"><div class="paragraph"><p>The core of all Particle Emitters is a ParticleController. That is used to manage all of the particles, the behaviour of the particles themselves though is controlled though a number of other classes that are plugged in to the ParticleController to provide the required functionality. You can think of the ParticleController as providing the central hub into which you plug all the modules you need to get the desired behaviour.</p></div>
<div class="paragraph"><p>An easy way to see what you need is to create a new ParticleController and then look at the constructor, you can see what parameters need to be supplied there.</p></div>
<table class="tableblock frame-all grid-all spread"><colgroup><col style="width: 50%;"><col style="width: 50%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">name</th><th class="tableblock halign-left valign-top">The name to use for the geometry in the scene graph</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>mesh</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The mesh to use (Usually either PointMesh or QuadMesh)</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>maxParticles</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The maximum number of particles to allow active at any one time</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>lifeMin</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The minimum amount of time (in seconds) for which each particle lives</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>lifeMax</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The maximum amount of time (in seconds) for which each particle lives</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>source</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The source from which the particles are spawned</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>emissionController</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>The frequency and timing with which particles are spawned. If null then no particles are automatically spawned and they must be triggered manually using emitNextParticle() or emitAllParticles()</p></div></div></td></tr><tr><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>influencers</p></div></div></td><td class="tableblock halign-left valign-top"><div><div class="paragraph"><p>Zero or more ParticleInfluencers, each of which changes the behaviour of the particles.</p></div></div></td></tr></tbody></table>
<div class="paragraph"><p>By selecting the behaviour you desire for each option you can configure up a virtually infinite array of possible particle emitters.</p></div>
<div class="paragraph"><p>We will now walk through some common examples and possible uses, and then in the end we will document all of the possible choices for these options.</p></div>
<div class="paragraph"><p>For a full reference of the standard options available see the <a href="../../jme3/contributions/particles/reference.html">Reference Page</a>.</p></div></div></div>
<div class="sect1"><h2 id="simple-fire">Simple Fire</h2><div class="sectionbody"><div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">HelloParticles1_SimpleFire</span> <span class="directive">extends</span> SimpleApplication {

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args){
        HelloParticles1_SimpleFire app = <span class="keyword">new</span> HelloParticles1_SimpleFire();
        app.start(); <span class="comment">// start the game</span>
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> simpleInitApp() {

<span class="comment">// Construct a new ParticleController</span>
        ParticleController pCtrl = <span class="keyword">new</span> ParticleController(
<span class="comment">// The name of the emitter</span>
                <span class="string"><span class="delimiter">&quot;</span><span class="content">SimpleFire</span><span class="delimiter">&quot;</span></span>,
<span class="comment">// Use a simple point mesh (the fastest but most limitted mesh type) with the specified</span>
<span class="comment">// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.</span>
                <span class="keyword">new</span> PointMesh(assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Effects/Explosion/flame.png</span><span class="delimiter">&quot;</span></span>, <span class="integer">2</span>, <span class="integer">2</span>),
<span class="comment">// Allow at most 32 particles at any time</span>
                <span class="integer">32</span>,
<span class="comment">// Particles last for at least 2 seconds</span>
                <span class="integer">2</span>,
<span class="comment">// And at most 3 seconds</span>
                <span class="integer">3</span>,
<span class="comment">// Point sources always generate particles at the location of the source, the particles</span>
<span class="comment">// are given a random velocity between the two given.</span>
                <span class="keyword">new</span> PointSource(<span class="keyword">new</span> Vector3f(-<span class="integer">3</span>, <span class="integer">0</span>, -<span class="integer">3</span>), <span class="keyword">new</span> Vector3f(<span class="integer">3</span>, <span class="integer">0</span>, <span class="integer">3</span>)),
<span class="comment">// Emit particles at regular intervals, 10 particles every second</span>
                <span class="keyword">new</span> RegularEmission(<span class="integer">10</span>),
<span class="comment">// ** Influencers start here</span>
<span class="comment">// Select a random sprite from the 4 available for each particle</span>
                <span class="keyword">new</span> RandomSpriteInfluencer(),
<span class="comment">// Particles start off with a size of 0.5 units, end with a radius of 0.1</span>
                <span class="keyword">new</span> SizeInfluencer(<span class="float">0.5f</span>, <span class="float">0.1f</span>),
<span class="comment">// Particles start yellow full opacity and fade towards red with very low opacity</span>
                <span class="keyword">new</span> ColorInfluencer(<span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>,<span class="integer">1</span>,<span class="float">0.2f</span>,<span class="integer">1</span>), <span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>,<span class="integer">0</span>,<span class="integer">0</span>,<span class="float">0.1f</span>)),
<span class="comment">// No matter what velocity particles started with they will start moving upwards.</span>
                <span class="keyword">new</span> PreferredDirectionInfluencer(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>, <span class="integer">1</span>, <span class="integer">0</span>), <span class="float">0.25f</span>));

<span class="comment">// Finally attach the geometry to the rootNode in order to start the particles running</span>
        rootNode.attachChild(pCtrl.getGeometry());
    }
}</code></pre></div></div>
<div class="paragraph"><p>Run that and the result should look something like:</p></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/particles1.jpg" alt="particles1.jpg" width="" height=""></span></p></div></div></div>
<div class="sect1"><h2 id="simple-fire-and-smoke">Simple Fire and Smoke</h2><div class="sectionbody"><div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> simpleInitApp() {

<span class="comment">// Construct a new ParticleController</span>
        ParticleController pCtrl = <span class="keyword">new</span> ParticleController(
<span class="comment">// The name of the emitter</span>
                <span class="string"><span class="delimiter">&quot;</span><span class="content">SimpleFire</span><span class="delimiter">&quot;</span></span>,
<span class="comment">// Use a simple point mesh (the fastest but most limitted mesh type) with the specified</span>
<span class="comment">// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.</span>
                <span class="keyword">new</span> PointMesh(assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Effects/Explosion/flame.png</span><span class="delimiter">&quot;</span></span>, <span class="integer">2</span>, <span class="integer">2</span>),
<span class="comment">// Allow at most 50 particles at any time, the particles are lasting longer this time</span>
<span class="comment">// so we need to allow more on screen at once</span>
                <span class="integer">50</span>,
<span class="comment">// Particles last for at least 4 seconds</span>
                <span class="integer">4</span>,
<span class="comment">// And at most 5 seconds</span>
                <span class="integer">5</span>,
<span class="comment">// Point sources always generate particles at the location of the source, the particles</span>
<span class="comment">// are given a random velocity between the two given.</span>
                <span class="keyword">new</span> PointSource(<span class="keyword">new</span> Vector3f(-<span class="integer">3</span>, <span class="integer">0</span>, -<span class="integer">3</span>), <span class="keyword">new</span> Vector3f(<span class="integer">3</span>, <span class="integer">0</span>, <span class="integer">3</span>)),
<span class="comment">// Emit particles at regular intervals, 10 particles every second</span>
                <span class="keyword">new</span> RegularEmission(<span class="integer">10</span>),
<span class="comment">// ** Influencers start here</span>
<span class="comment">// Select a random sprite from the 4 available for each particle</span>
                <span class="keyword">new</span> RandomSpriteInfluencer(),
<span class="comment">// Particles start off with a size of 0.5 units, end with a radius of 0.1</span>
                <span class="keyword">new</span> SizeInfluencer(<span class="float">0.5f</span>, <span class="float">0.25f</span>),
<span class="comment">// Particles start yellow full opacity and fade towards red with very low opacity</span>
                <span class="keyword">new</span> MultiColorInfluencer(
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="integer">0</span>, <span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>, <span class="integer">1</span>, <span class="float">0.1f</span>, <span class="integer">1</span>)),
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="float">0.15f</span>, <span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>, <span class="float">0.25f</span>)),
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="float">0.3f</span>, <span class="keyword">new</span> ColorRGBA(<span class="float">1f</span>, <span class="float">1f</span>, <span class="float">1f</span>, <span class="float">0.5f</span>)),
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="integer">1</span>, <span class="keyword">new</span> ColorRGBA(<span class="float">1f</span>,<span class="float">1f</span>,<span class="float">1f</span>,<span class="float">0f</span>))
                ),
<span class="comment">// No matter what velocity particles started with they will start moving upwards.</span>
                <span class="keyword">new</span> PreferredDirectionInfluencer(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>, <span class="integer">1</span>, <span class="integer">0</span>), <span class="float">0.25f</span>));

<span class="comment">// Finally attach the geometry to the rootNode in order to start the particles running</span>
        rootNode.attachChild(pCtrl.getGeometry());
    }</code></pre></div></div>
<div class="paragraph"><p>You can see that the only change is to make the particles last a little longer and to change the ColorInfluencer for a MultiColorInfluencer, and yet the results look quite different:</p></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/particles2.jpg" alt="particles2.jpg" width="" height=""></span></p></div>
<div class="paragraph"><p>This isn&#8217;t a very convincing fire yet, but it is very simple to get up and running. One problem with this approach is that particles are done using an alpha-additive material, they can only make things brighter but never darker. That is not ideal for smoke which should be able to make them darker too. We will look at this again later but for now we will move on to some different mesh types.</p></div></div></div>
<div class="sect1"><h2 id="quad-meshes-and-billboarding">Quad Meshes and Billboarding</h2><div class="sectionbody"><div class="paragraph"><p>Point Meshes are extremely fast, but they have a number of limitations. The main ones being that the sprites must always be facing towards the screen and that on certain graphics cards the maximum number of pixels a sprite can occupy on the screen is limited.</p></div>
<div class="paragraph"><p>While PointMesh is recommended for basic particles for more advanced options there is the QuadMesh, this constructs each particle using a quad and as a result can allow any size on the screen and any orientation. The following example combines two separate particle emitters to produce a spell-like effect.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="paragraph"><p>The flame image from before is used for the second emitter, the first emitter uses this image which you can download and use:</p></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/runecircle.png" alt="runecircle.png" width="256" height=""></span></p></div></td></tr></table></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> simpleInitApp() {

<span class="comment">// Construct a new ParticleController to provide the actual spell runes effect</span>
        ParticleController pCtrl = <span class="keyword">new</span> ParticleController(
<span class="comment">// The name of the emitter</span>
                <span class="string"><span class="delimiter">&quot;</span><span class="content">SpellRunes</span><span class="delimiter">&quot;</span></span>,
<span class="comment">// Use a Quad Mesh, this image is available for download on this page. The texture file contains</span>
<span class="comment">// a single image so there are no sprite columns and rows to set up. The BillboardStrategy is how</span>
<span class="comment">// the particles should be oriented, in this case it uses the particle rotation.</span>
                <span class="keyword">new</span> QuadMesh(QuadMeshBillboardStrategy.USE_PARTICLE_ROTATION, assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Textures/runeCircle.png</span><span class="delimiter">&quot;</span></span>),
<span class="comment">// Allow at most 9 particles at any time</span>
                <span class="integer">9</span>,
<span class="comment">// Particles always last for 4 seconds</span>
                <span class="integer">4</span>,
                <span class="integer">4</span>,
<span class="comment">// We want to generate all particles from the same location with the same velocity.</span>
                <span class="keyword">new</span> PointSource(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>, <span class="float">1f</span>, <span class="integer">0</span>), <span class="keyword">new</span> Vector3f(<span class="integer">0</span>, <span class="float">1f</span>, <span class="integer">0</span>)),
<span class="comment">// Emit particles at regular intervals, 4 particles every second</span>
                <span class="keyword">new</span> RegularEmission(<span class="integer">2</span>),
<span class="comment">// ** Influencers start here</span>
<span class="comment">// These particles should be size 3 and stay the same size</span>
                <span class="keyword">new</span> SizeInfluencer(<span class="integer">3</span>, <span class="integer">3</span>),
<span class="comment">// Start the particles at full opacity blue and then fade them out to 0 opacity cyan.</span>
                <span class="keyword">new</span> ColorInfluencer(ColorRGBA.Blue, <span class="keyword">new</span> ColorRGBA(<span class="integer">0</span>, <span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">0</span>)),
<span class="comment">// Rotate all particles by the same amount. The units are radians-per-second</span>
                <span class="keyword">new</span> RotationInfluencer(
                    <span class="keyword">new</span> Vector3f(<span class="integer">0</span>, FastMath.QUARTER_PI, <span class="integer">0</span>),
                    <span class="keyword">new</span> Vector3f(<span class="integer">0</span>, FastMath.QUARTER_PI, <span class="integer">0</span>), <span class="predefined-constant">false</span>));

<span class="comment">// Finally attach the geometry to the rootNode in order to start the particles running</span>
        rootNode.attachChild(pCtrl.getGeometry());


<span class="comment">// Construct a new ParticleController to provide the central glow effect</span>
        pCtrl = <span class="keyword">new</span> ParticleController(
<span class="comment">// The name of the emitter</span>
                <span class="string"><span class="delimiter">&quot;</span><span class="content">SpellBase</span><span class="delimiter">&quot;</span></span>,
<span class="comment">// Use a simple point mesh (the fastest but most limitted mesh type) with the specified</span>
<span class="comment">// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.</span>
                <span class="keyword">new</span> PointMesh(assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Textures/flame.png</span><span class="delimiter">&quot;</span></span>, <span class="integer">2</span>, <span class="integer">2</span>),
<span class="comment">// Allow at most 76 particles at any time</span>
                <span class="integer">76</span>,
<span class="comment">// Particles last for at least 5 seconds</span>
                <span class="integer">5</span>,
<span class="comment">// And at most 5 seconds</span>
                <span class="integer">5</span>,
<span class="comment">// Point sources always generate particles at the location of the source, the particles</span>
<span class="comment">// are given a random velocity between the two given.</span>
                <span class="keyword">new</span> PointSource(<span class="keyword">new</span> Vector3f(-<span class="float">1f</span>, <span class="integer">0</span>, -<span class="float">1f</span>), <span class="keyword">new</span> Vector3f(<span class="float">1f</span>, <span class="float">0.5f</span>, <span class="float">1f</span>)),
<span class="comment">// Emit particles at regular intervals, 15 particles every second</span>
                <span class="keyword">new</span> RegularEmission(<span class="integer">15</span>),
<span class="comment">// ** Influencers start here</span>
<span class="comment">// Select a random sprite from the 4 available for each particle</span>
                <span class="keyword">new</span> RandomSpriteInfluencer(),
<span class="comment">// Particles start red with some blue and green and fade towards blue zero opacity</span>
<span class="comment">// Because particles are rendered using an additive blend then any area where a lot</span>
<span class="comment">// of particles overlap will end up white.</span>
                <span class="keyword">new</span> ColorInfluencer(<span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>,<span class="float">0.25f</span>,<span class="float">0.25f</span>,<span class="float">0.25f</span>), <span class="keyword">new</span> ColorRGBA(<span class="integer">0</span>,<span class="integer">0</span>,<span class="integer">1</span>,<span class="float">0f</span>)));

<span class="comment">// Finally attach the geometry to the rootNode in order to start the particles running</span>
        rootNode.attachChild(pCtrl.getGeometry());


        cam.setLocation(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>, <span class="integer">10</span>, -<span class="integer">10</span>));
        cam.lookAt(Vector3f.ZERO, Vector3f.UNIT_Y);
    }</code></pre></div></div>
<div class="paragraph"><p>The result should look something like:</p></div>
<div class="ulist"><ul><li><p><a href="https://www.youtube.com/watch?v=_Spjqag99HY">Video: Particle Emitter Example 1</a></p></li></ul></div></div></div>
<div class="sect1"><h2 id="using-a-mesh-as-the-particle-source">Using a mesh as the particle source</h2><div class="sectionbody"><div class="paragraph"><p>There is a model of a monkeys head in the test data that is used in this example, although you can use any other model you like. Just make sure you can find the geometry within the model for the next step.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> simpleInitApp() {

        Node monkey = (Node) assetManager.loadModel(<span class="string"><span class="delimiter">&quot;</span><span class="content">Models/MonkeyHead/MonkeyHead.mesh.xml</span><span class="delimiter">&quot;</span></span>);
        rootNode.attachChild(monkey);

        DirectionalLight dl = <span class="keyword">new</span> DirectionalLight();
        dl.setDirection(<span class="keyword">new</span> Vector3f(-<span class="float">0.1f</span>,-<span class="float">0.7f</span>,-<span class="integer">1</span>).normalizeLocal());
        dl.setColor(<span class="keyword">new</span> ColorRGBA(<span class="float">0.88f</span>, <span class="float">0.60f</span>, <span class="float">0.60f</span>, <span class="float">1.0f</span>));
        rootNode.addLight(dl);

        AmbientLight al = <span class="keyword">new</span> AmbientLight();
        al.setColor(ColorRGBA.White);
        rootNode.addLight(al);</code></pre></div></div>
<div class="paragraph"><p>The result should look something like:</p></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/particles3.jpg" alt="particles3.jpg" width="" height=""></span></p></div>
<div class="paragraph"><p>Now lets set fire to the monkey! (No monkeys were harmed during the making of this particle system!).</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Construct a new ParticleController</span>
        ParticleController pCtrl = <span class="keyword">new</span> ParticleController(
<span class="comment">// The name of the emitter</span>
                <span class="string"><span class="delimiter">&quot;</span><span class="content">SimpleFire</span><span class="delimiter">&quot;</span></span>,
<span class="comment">// Use a simple point mesh (the fastest but most limitted mesh type) with the specified</span>
<span class="comment">// image (from jME3-testdata). The image actually contains a 2x2 grid of sprites.</span>
                <span class="keyword">new</span> PointMesh(assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Textures/flame.png</span><span class="delimiter">&quot;</span></span>, <span class="integer">2</span>, <span class="integer">2</span>),
<span class="comment">// Allow at most 1200 particles at any time, the particles are lasting longer this time</span>
<span class="comment">// so we need to allow more on screen at once</span>
                <span class="integer">1200</span>,
<span class="comment">// Particles last for at least 4 seconds</span>
                <span class="integer">4</span>,
<span class="comment">// And at most 5 seconds</span>
                <span class="integer">5</span>,
<span class="comment">// A MeshSource scans a geometry and picks a random point on the surface of that</span>
<span class="comment">// geometry in order to emit the particle from it. The particle has an inital velocity</span>
<span class="comment">// of 1wu/s along the normal of the triangle from which it is emitted.</span>
                <span class="keyword">new</span> MeshSource(g),
<span class="comment">// Emit particles at regular intervals, 10 particles every second</span>
                <span class="keyword">new</span> RegularEmission(<span class="integer">240</span>),
<span class="comment">// ** Influencers start here</span>
<span class="comment">// Select a random sprite from the 4 available for each particle</span>
                <span class="keyword">new</span> RandomSpriteInfluencer(),
<span class="comment">// Particles start off with a size of 0.1 units, end with a size of 0.15</span>
                <span class="keyword">new</span> SizeInfluencer(<span class="float">0.1f</span>, <span class="float">0.15f</span>),
<span class="comment">// Particles have a constant speed of 0.25f, this will modify the original speed</span>
<span class="comment">// from the emitter and then allow the GravityInfluencer to change the direction</span>
<span class="comment">// of motion but constrain the speed</span>
                <span class="keyword">new</span> SpeedInfluencer(<span class="float">0.25f</span>, <span class="float">0.25f</span>),
<span class="comment">// Fade the paticles through a range of colours</span>
                <span class="keyword">new</span> MultiColorInfluencer(
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="integer">0</span>, <span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>, <span class="integer">1</span>, <span class="float">0.1f</span>, <span class="integer">1</span>)),
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="float">0.25f</span>, <span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>, <span class="integer">0</span>, <span class="integer">0</span>, <span class="float">0.25f</span>)),
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="float">0.5f</span>, <span class="keyword">new</span> ColorRGBA(<span class="float">1f</span>, <span class="float">1f</span>, <span class="float">1f</span>, <span class="float">0.25f</span>)),
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="integer">1</span>, <span class="keyword">new</span> ColorRGBA(<span class="float">1f</span>,<span class="float">1f</span>,<span class="float">1f</span>,<span class="float">0f</span>))
                ),
<span class="comment">// No matter what velocity particles started with they will start moving upwards.</span>
                <span class="keyword">new</span> GravityInfluencer(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>, <span class="float">0.5f</span>, <span class="integer">0</span>)));

<span class="comment">// Finally attach the geometry to the rootNode in order to start the particles running</span>
        rootNode.attachChild(pCtrl.getGeometry());</code></pre></div></div>
<div class="paragraph"><p>Again this is just a very simple example, much more sophisticated fire effects are possible with the use of the right textures and mixture of emitters and influencers. The result though should look something like this:</p></div>
<div class="ulist"><ul><li><p><a href="https://www.youtube.com/watch?v=W__zGJHZ2AU">Video: Particle Emitter Example 2</a></p></li></ul></div></div></div>
<div class="sect1"><h2 id="meshes-and-weighted-meshes">Meshes and Weighted Meshes</h2><div class="sectionbody"><div class="paragraph"><p>The previous example uses a MeshSource, this picks a random triangle from the mesh without any regard given to the size of different triangles. This means areas with small triangles are actually more likely to emit particles than areas with large triangles. For most meshes this is not visible, however there is a WeightedMeshSource available if this should be a problem.</p></div>
<div class="paragraph"><p>The WeightedMeshSource scans the mesh and works out a weight for each triangle based on its relative size, so that the result is an even spread of particles even with very large differences in triangle sizes. There are some limitations with this though:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>The WeightedMeshSource consumes more memory as it needs to remember the weights</p></li><li><p>The WeightedMeshSource is slower as it needs to do more work to pick a triangle</p></li><li><p>The WeightedMeshSource does not update automatically if the mesh changes, if triangles are added they will not emit, if triangles are removed it could cause a crash. If triangles change shape then the weights are not updated.</p></li></ol></div>
<div class="paragraph"><p>There is a method available to cause the weights to be recalculated which can be used if changing the mesh, but really if possible a non-weighted MeshSource should be used for dynamic meshes.</p></div></div></div>
<div class="sect1"><h2 id="3d-particles-templatemesh">3d Particles - TemplateMesh</h2><div class="sectionbody"><div class="paragraph"><p>The previous mesh examples all use simple 2d quads to display images. There is another mesh type though, the TemplateMesh, which allows fully featured 3d particles to be used.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="paragraph"><p>There is a rock texture available in the jME3 test data, or you can substitute any other suitable texture. The model for this example is: <a href="http://www.zero-separation.com/particles/FracturedCube.j3o">FracturedCube.j3o</a></p></div></td></tr></table></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> simpleInitApp() {

        <span class="comment">// Since we actually use a full lit material for these particles we need</span>
        <span class="comment">// to add a light to the scene in order to see anything.</span>
        DirectionalLight dl = <span class="keyword">new</span> DirectionalLight();
        dl.setDirection(<span class="keyword">new</span> Vector3f(-<span class="float">0.1f</span>,-<span class="float">0.7f</span>,-<span class="integer">1</span>).normalizeLocal());
        dl.setColor(<span class="keyword">new</span> ColorRGBA(<span class="float">0.6f</span>, <span class="float">0.60f</span>, <span class="float">0.60f</span>, <span class="float">1.0f</span>));
        rootNode.addLight(dl);

<span class="comment">// A standard lit material is used, this rock texture was taking from the</span>
<span class="comment">// jme3 test data but you can easily substitute your own.</span>
        Material rock = <span class="keyword">new</span> Material(assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Common/MatDefs/Light/Lighting.j3md</span><span class="delimiter">&quot;</span></span>);
        rock.setTexture(<span class="string"><span class="delimiter">&quot;</span><span class="content">DiffuseMap</span><span class="delimiter">&quot;</span></span>, assetManager.loadTexture(<span class="string"><span class="delimiter">&quot;</span><span class="content">Textures/Rock.PNG</span><span class="delimiter">&quot;</span></span>));
        rock.setFloat(<span class="string"><span class="delimiter">&quot;</span><span class="content">Shininess</span><span class="delimiter">&quot;</span></span>, <span class="float">100f</span>);

<span class="comment">// A PointSource is actually a fully featured Spatial object, in this case</span>
<span class="comment">// we simply adjust its translation, but it can actually be attached to the</span>
<span class="comment">// scene graph and the source will automatically move as the Node to which</span>
<span class="comment">// it is attached is transformed.</span>
        PointSource source = <span class="keyword">new</span> PointSource(<span class="keyword">new</span> Vector3f(-<span class="integer">5</span>,-<span class="integer">5</span>,-<span class="integer">5</span>), <span class="keyword">new</span> Vector3f(<span class="integer">5</span>,<span class="integer">5</span>,<span class="integer">5</span>));
        source.setLocalTranslation(<span class="integer">0</span>, <span class="integer">10</span>, -<span class="integer">20</span>);

<span class="comment">// A TemplateMesh uses any number of standard meshes to be the template for</span>
<span class="comment">// each 3d particle. This model was generated simply by taking a cube in</span>
<span class="comment">// Blender and running a fracture script on it to generate 20 fragments.</span>
        Node n = (Node) assetManager.loadModel(<span class="string"><span class="delimiter">&quot;</span><span class="content">Models/FracturedCube.j3o</span><span class="delimiter">&quot;</span></span>);
        Mesh<span class="type">[]</span> templates = <span class="keyword">new</span> Mesh[n.getChildren().size()];
        <span class="type">int</span> i = <span class="integer">0</span>;
        <span class="keyword">for</span> (Spatial s: n.getChildren()) {
            Geometry g = (Geometry)((Node)s).getChild(<span class="integer">0</span>);
            templates[i++] = g.getMesh();
        }

<span class="comment">// Construct the new particle controller</span>
        ParticleController rockCtrl = <span class="keyword">new</span> ParticleController(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">TemplateMesh</span><span class="delimiter">&quot;</span></span>,
<span class="comment">// The TemplateMesh uses the rock material we created previously, the two boolean</span>
<span class="comment">// flags say that we are not interested in vertex colours but we do want the vertex</span>
<span class="comment">// normals. The array of meshes extracted from the model is then passed in to use</span>
<span class="comment">// as models for each particle.</span>
                <span class="keyword">new</span> TemplateMesh(rock, <span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>, templates),
<span class="comment">// A maximum of 64 particles at once, each lasting for 5 to 5.5 seconds.</span>
                <span class="integer">64</span>,
                <span class="integer">5</span>,
                <span class="float">5.5f</span>,
<span class="comment">// Particles are emitted from the source that we created and positioned earlier</span>
                source,
<span class="comment">// Emit 8 particles per second</span>
                <span class="keyword">new</span> RegularEmission(<span class="integer">8</span>),
<span class="comment">// The &quot;sprites&quot; in this case are the available templates. The TemplateMesh has</span>
<span class="comment">// one spriteColumn for each template it has been provided, so the standard</span>
<span class="comment">// RandomSpriteInfluencer just causes one to be picked at random each time a</span>
<span class="comment">// particle is emitted.</span>
                <span class="keyword">new</span> RandomSpriteInfluencer(),
<span class="comment">// Rocks fall.</span>
                <span class="keyword">new</span> GravityInfluencer(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>, -<span class="integer">4</span>, <span class="integer">0</span>)),
<span class="comment">// Rocks spin.</span>
                <span class="keyword">new</span> RotationInfluencer(<span class="keyword">new</span> Vector3f(-<span class="integer">2</span>, -<span class="integer">2</span>, -<span class="integer">2</span>), <span class="keyword">new</span> Vector3f(<span class="integer">2</span>, <span class="integer">2</span>, <span class="integer">2</span>), <span class="predefined-constant">false</span>));

        rootNode.attachChild(rockCtrl.getGeometry());
    }</code></pre></div></div>
<div class="paragraph"><p>The result should look like:</p></div>
<div class="ulist"><ul><li><p><a href="https://www.youtube.com/watch?v=a7y53UF8Giw">Video: Particle Emitter Example 3</a></p></li></ul></div>
<div class="paragraph"><p>Any number and mixture of models can be used, although as it is all a single mesh the same material must be used for all of them. It is recommended to keep a similar number of vertices for each of the models but that is not a strict requirement.</p></div></div></div>
<div class="sect1"><h2 id="emitting-particles-from-particles">Emitting Particles from Particles</h2><div class="sectionbody"><div class="paragraph"><p>To add more dramatic effects sometimes you want to emit particles from particles, this could be done simply by attaching a MeshSource for the second controller to the mesh from the first controller. There are a number of limitations to this approach though, which will be demonstrated now:</p></div>
<div class="paragraph"><p>Adding the following code:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">        ParticleController pCtrl = <span class="keyword">new</span> ParticleController(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">TemplateFlames</span><span class="delimiter">&quot;</span></span>,
                <span class="keyword">new</span> PointMesh(assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Textures/flame.png</span><span class="delimiter">&quot;</span></span>, <span class="integer">2</span>, <span class="integer">2</span>),
                <span class="integer">1300</span>,
                <span class="integer">3</span>,
                <span class="integer">4</span>,
                <span class="keyword">new</span> MeshSource(rockCtrl.getGeometry()),
                <span class="keyword">new</span> RegularEmission(<span class="integer">320</span>),
                <span class="keyword">new</span> SizeInfluencer(<span class="float">0.5f</span>, <span class="integer">2</span>),
                <span class="keyword">new</span> ColorInfluencer(<span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>,<span class="integer">1</span>,<span class="float">0.1f</span>, <span class="float">1f</span>), <span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>,<span class="integer">0</span>,<span class="integer">0</span>,<span class="float">0.05f</span>)),
                <span class="keyword">new</span> GravityInfluencer(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>, <span class="float">0.3f</span>, <span class="integer">0</span>)),
                <span class="keyword">new</span> RandomImpulseInfluencer(
                    RandomImpulseInfluencer.ImpulseApplicationTime.INITIALIZE,
                    <span class="keyword">new</span> Vector3f(-<span class="float">0.5f</span>, -<span class="float">0.5f</span>, -<span class="float">0.5f</span>),
                    <span class="keyword">new</span> Vector3f(<span class="float">0.5f</span>, <span class="float">0.5f</span>, <span class="float">0.5f</span>)));

        rootNode.attachChild(pCtrl.getGeometry());</code></pre></div></div>
<div class="paragraph"><p>Results in something that looks like this:</p></div>
<div class="ulist"><ul><li><p><a href="https://www.youtube.com/watch?v=WGR5RzF9APg">Video: Particle Emitter Example 3</a></p></li></ul></div>
<div class="paragraph"><p>You can see that while dramatic the fire is left behind each particle, this is because although it is emitted from the face of the particle at its current position it has no knowledge of how that particle is moving.</p></div>
<div class="paragraph"><p>To allow for this we also offer a different emitter, this allows one ParticleController to act as the source for another. The emitted particles are then able to start with the same velocity and rotation of the particle they are being emitted from and then move onwards from there as appropriate.</p></div>
<div class="paragraph"><p>Leave everything else the same but change the MeshSource into</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">                <span class="keyword">new</span> ParticleParticleSource(rockCtrl),</code></pre></div></div>
<div class="paragraph"><p>You can see that this gives much better results:</p></div>
<div class="ulist"><ul><li><p><a href="https://www.youtube.com/watch?v=2BlBZVM0EZQ">Video: Particle Emitter Example 4</a></p></li></ul></div>
<div class="paragraph"><p>There is a lot of falling rocks and fire here, but not much in the way of smoke. That could be added using a multi-colour emitter as previously, but the standard particle material is additive. That means it can only make colours brighter, never darker. For smoke it should be able to darken as well as lighten.</p></div>
<div class="paragraph"><p>To add smoke we can add a third emitter after the other two:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Construct a new material for the smoke based off the default particle material</span>
        Material smokeMat = <span class="keyword">new</span> Material(
               assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Common/MatDefs/Misc/Particle.j3md</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// The Smoke.png texture can be found in the jme3 test data</span>
        smokeMat.setTexture(<span class="string"><span class="delimiter">&quot;</span><span class="content">Texture</span><span class="delimiter">&quot;</span></span>,
            assetManager.loadTexture(<span class="string"><span class="delimiter">&quot;</span><span class="content">Textures/Smoke.png</span><span class="delimiter">&quot;</span></span>));
<span class="comment">// Set the blend mode to Alpha rather than AlphaAdditive so that dark smoke</span>
<span class="comment">// can darken the scene behind it</span>
        smokeMat.getAdditionalRenderState().setBlendMode(RenderState.BlendMode.Alpha);
<span class="comment">// For point sprite meshes this parameter must be set</span>
        smokeMat.setBoolean(<span class="string"><span class="delimiter">&quot;</span><span class="content">PointSprite</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">true</span>);

<span class="comment">// Construct the new particle controller</span>
        pCtrl = <span class="keyword">new</span> ParticleController(
                <span class="string"><span class="delimiter">&quot;</span><span class="content">TemplateSmoke</span><span class="delimiter">&quot;</span></span>,
<span class="comment">// The Smoke.png texture contains 15 sprites, if you use a different texture adjust</span>
<span class="comment">// these parameters accordingly.</span>
                <span class="keyword">new</span> PointMesh(smokeMat, <span class="integer">15</span>, <span class="integer">1</span>),
                <span class="integer">800</span>,
                <span class="integer">4</span>,
                <span class="integer">5</span>,
                <span class="keyword">new</span> ParticleParticleSource(rockCtrl),
                <span class="keyword">new</span> RegularEmission(<span class="integer">180</span>),
                <span class="keyword">new</span> SizeInfluencer(<span class="float">1f</span>, <span class="float">2.5f</span>),
                <span class="keyword">new</span> MultiColorInfluencer(
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="integer">0</span>, <span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">0</span>)),
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="float">0.5f</span>, <span class="keyword">new</span> ColorRGBA(<span class="integer">0</span>, <span class="integer">0</span>, <span class="integer">0</span>, <span class="float">0.5f</span>)),
                    <span class="keyword">new</span> MultiColorInfluencer.Stage(<span class="integer">1</span>, <span class="keyword">new</span> ColorRGBA(<span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">1</span>, <span class="integer">0</span>))),
                <span class="keyword">new</span> GravityInfluencer(<span class="keyword">new</span> Vector3f(<span class="integer">0</span>, <span class="float">0.75f</span>, <span class="integer">0</span>)),
                <span class="keyword">new</span> RandomImpulseInfluencer(
                    RandomImpulseInfluencer.ImpulseApplicationTime.INITIALIZE,
                    <span class="keyword">new</span> Vector3f(-<span class="float">0.5f</span>, -<span class="float">0.5f</span>, -<span class="float">0.5f</span>),
                    <span class="keyword">new</span> Vector3f(<span class="float">0.5f</span>, <span class="float">0.5f</span>, <span class="float">0.5f</span>)));

        rootNode.attachChild(pCtrl.getGeometry());</code></pre></div></div>
<div class="paragraph"><p>The results look something like:</p></div>
<div class="ulist"><ul><li><p><a href="https://www.youtube.com/watch?v=01qCBGBvf-c">Video: Particle Emitter Example 5</a></p></li></ul></div>
<div class="paragraph"><p>To complete the effect one final line of code adds a skybox (using another texture that can be find in the test data):</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">        rootNode.attachChild(SkyFactory.createSky(assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Textures/BrightSky.dds</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">false</span>));</code></pre></div></div>
<div class="paragraph"><p>Now we have the final effect which looks like:</p></div>
<div class="ulist"><ul><li><p><a href="https://www.youtube.com/watch?v=uDeWAjw4LxU">Video: Particle Emitter Example 6</a></p></li></ul></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2020-06-11 12:23:11 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>