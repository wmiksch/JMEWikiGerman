<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><meta name="keywords" content="loop, game, performance, state, states, documentation"><title>Multithreading Optimization</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"><link rel="stylesheet" href="/home/travis/build/wmiksch/JMEWikiGerman/build/asciidoc/html5/jme3/advanced/twemoji-awesome.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/wmiksch/JMEWikiGerman/edit/master/src/docs/asciidoc/jme3/advanced/multithreading.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/wmiksch/JMEWikiGerman/new/master/src/docs/asciidoc/jme3/advanced/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>Multithreading Optimization</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Inhaltsverzeichnis</div><ul class="sectlevel1"><li><a href="#the-jme3-threading-model">The jME3 Threading Model</a><ul class="sectlevel2"><li><a href="#java-multithreading">Java Multithreading</a></li><li><a href="#multithreading-in-jme3">Multithreading in jME3</a></li></ul></li><li><a href="#executor">Executor</a></li><li><a href="#control-class-fields">Control Class Fields</a></li><li><a href="#control-update-method">Control Update() Method</a></li><li><a href="#the-callable">The Callable</a><ul class="sectlevel2"><li><a href="#useful-links">Useful Links</a></li><li><a href="#conclusion">Conclusion</a></li></ul></li></ul></div></div><div id="content"><div class="sect2"><h3 id="the-jme3-threading-model">The jME3 Threading Model</h3><div class="paragraph"><p>jME3 is similar to Swing in that, for speed and efficiency, all changes to the scene graph must be made in a single update thread. If you make changes only in Control.update(), AppState.update(), or SimpleApplication.simpleUpdate(), this will happen automatically.  However, if you pass work to another thread, you may need to pass results back to the main jME3 thread so that scene graph changes can take place there.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> rotateGeometry(<span class="directive">final</span> Geometry geo, <span class="directive">final</span> Quaternion rot) {
    mainApp.enqueue(<span class="keyword">new</span> <span class="predefined-type">Callable</span>&lt;Spatial&gt;() {
        <span class="directive">public</span> Spatial call() <span class="directive">throws</span> <span class="exception">Exception</span> {
            <span class="keyword">return</span> geo.rotate(rot);
        }
    });
}</code></pre></div></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="paragraph"><p>This example does not fetch the returned value by calling <code>get()</code> on the Future object returned from <code>enqueue()</code>. This means that the example method <code>rotateGeometry()</code> will return immediately and will not wait for the rotation to be processed before continuing.</p></div>
<div class="paragraph"><p>If the processing thread needs to wait or needs the return value then <code>get()</code> or the other methods in the returned Future object such as <code>isDone()</code> can be used.</p></div></td></tr></table></div>
<div class="paragraph"><p>First, make sure you know what <a href="../../jme3/advanced/application_states.html">Application States</a> and <a href="../../jme3/advanced/custom_controls.html">Custom Controls</a> are.</p></div>
<div class="paragraph"><p>More complex games may feature complex mathematical operations or artificial intelligence calculations (such as path finding for several NPCs). If you make many time-intensive calls on the same thread (in the update loop), they will block one another, and thus slow down the game to a degree that makes it unplayable. If your game requires long running tasks, you should run them concurrently on separate threads, which speeds up the application considerably.</p></div>
<div class="paragraph"><p>Often multithreading means having separate detached logical loops going on in parallel, which communicate about their state. (For example, one thread for AI, one Sound, one Graphics). However we recommend to use a global update loop for game logic, and do multithreading within that loop when it is appropriate. This approach scales way better to multiple cores and does not break up your code logic.</p></div>
<div class="paragraph"><p>Effectively, each for-loop in the main update loop might be a chance for multithreading, if you can break it up into self-contained tasks.</p></div>
<div class="sect2"><h3 id="java-multithreading">Java Multithreading</h3><div class="paragraph"><p>The java.util.concurrent package provides a good foundation for multithreading and dividing work into tasks that can be executed concurrently (hence the name). The three basic components are the Executor (supervises threads), Callable Objects (the tasks), and Future Objects (the result). You can <a href="http://download.oracle.com/javase/tutorial/essential/concurrency/">read about the concurrent package more here</a>, I will give just a short introduction.</p></div>
<div class="ulist"><ul><li><p>A Callable is one of the classes that gets executed on a thread in the Executor. The object represents one of several concurrent tasks (e.g, one NPC&#8217;s path finding task). Each Callable is started from the updateloop by calling a method named <code>call()</code>.</p></li><li><p>The Executor is one central object that manages all your Callables. Every time you schedule a Callable in the Executor, the Executor returns a Future object for it.</p></li><li><p>A Future is an object that you use to check the status of an individual Callable task. The Future also gives you the return value in case one is returned.</p></li></ul></div></div>
<div class="sect2"><h3 id="multithreading-in-jme3">Multithreading in jME3</h3><div class="paragraph"><p>So how do we implement multithreading in jME3?</p></div>
<div class="paragraph"><p>Let&#8217;s take the example of a Control that controls an NPC Spatial. The NPC Control has to compute a lengthy pathfinding operation for each NPC. If we would execute the operations directly in the simpleUpdate() loop, it would block the game  each time a NPC wants to move from A to B. Even if we move this behaviour into the update() method of a dedicated NPC Control, we would still get annoying freeze frames, because it still runs on the same update loop thread.</p></div>
<div class="paragraph"><p>To avoid slowdown, we decide to keep the pathfinding operations in the NPC Control, <em>but execute it on another thread</em>.</p></div></div></div>
<div class="sect1"><h2 id="executor">Executor</h2><div class="sectionbody"><div class="paragraph"><p>You create the executor object in a global AppState (or the initSimpleApp() method), in any case in a high-level place where multiple controls can access it.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* This constructor creates a new executor with a core pool size of 4. */</span>
<span class="predefined-type">ScheduledThreadPoolExecutor</span> executor = <span class="keyword">new</span> <span class="predefined-type">ScheduledThreadPoolExecutor</span>(<span class="integer">4</span>);</code></pre></div></div>
<div class="paragraph"><p>Pool size means the executor will keep four threads alive at any time. Having more threads in the pool means that more tasks can run concurrently. But a bigger pool only results in a speed gain if the PC can handle it! Allocating a pool  that is uselessly large just wastes memory, so you need to find a good compromise: About the same to double the size of the number of cores in the computer makes sense.</p></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><i class="fa icon-warning" title="Warning"></i></td><td class="content"><div class="paragraph"><p>Executor needs to be shut down when the application ends, in order to make the process die properly
In your simple application you can override the destroy method and shutdown the executor:</p></div></td></tr></table></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> destroy() {
        <span class="local-variable">super</span>.destroy();
        executor.shutdown();
    }</code></pre></div></div></div></div>
<div class="sect1"><h2 id="control-class-fields">Control Class Fields</h2><div class="sectionbody"><div class="paragraph"><p>In the NPC Control, we create the individual objects that the thread manipulates. In our example case (the pathfinding control), the task is about locations and path arrays, so we need the following variables:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="Java"><span class="comment">//The vector to store the desired location in:</span>
Vector3f desiredLocation = <span class="keyword">new</span> Vector3f();
<span class="comment">//The MyWayList object that contains the result waylist:</span>
MyWayList wayList = <span class="predefined-constant">null</span>;
<span class="comment">//The future that is used to check the execution status:</span>
<span class="predefined-type">Future</span> future = <span class="predefined-constant">null</span>;</code></pre></div></div>
<div class="paragraph"><p>Here we also created the Future variable to track the state of this task.</p></div></div></div>
<div class="sect1"><h2 id="control-update-method">Control Update() Method</h2><div class="sectionbody"><div class="paragraph"><p>Next let&#8217;s look at the update() call of the Control where the time-intensive task starts. In our example, the task is the <code>findWay</code> Callable (which contains the pathfinding process). So instead of spelling out the pathfinding process  in the Control&#8217;s update() loop, we start the process via <code>future = executor.submit(findWay);</code>.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> update(<span class="type">float</span> tpf) {
    <span class="keyword">try</span>{
        <span class="comment">//If we have no waylist and not started a callable yet, do so!</span>
        <span class="keyword">if</span>(wayList == <span class="predefined-constant">null</span> &amp;&amp; future == <span class="predefined-constant">null</span>){
            <span class="comment">//set the desired location vector, after that we should not modify it anymore</span>
            <span class="comment">//because it's being accessed on the other thread!</span>
            desiredLocation.set(getGoodNextLocation());
            <span class="comment">//start the callable on the executor</span>
            future = executor.submit(findWay);    <span class="comment">//  Thread starts!</span>
        }
        <span class="comment">//If we have started a callable already, we check the status</span>
        <span class="keyword">else</span> <span class="keyword">if</span>(future != <span class="predefined-constant">null</span>){
            <span class="comment">//Get the waylist when its done</span>
            <span class="keyword">if</span>(future.isDone()){
                wayList = future.get();
                future = <span class="predefined-constant">null</span>;
            }
            <span class="keyword">else</span> <span class="keyword">if</span>(future.isCancelled()){
                <span class="comment">//Set future to null. Maybe we succeed next time...</span>
                future = <span class="predefined-constant">null</span>;
            }
        }
    }
    <span class="keyword">catch</span>(<span class="exception">Exception</span> e){
      Exceptions.printStackTrace(e);
    }
    <span class="keyword">if</span>(wayList != <span class="predefined-constant">null</span>){
        <span class="comment">//.... Success! Let's process the wayList and move the NPC...</span>
    }
}</code></pre></div></div>
<div class="paragraph"><p>Note how this logic makes its decision based on the Future object.</p></div>
<div class="paragraph"><p>Remember not to mess with the class fields after starting the thread, because they are being accessed and modified on the new thread. In more obvious terms: You cannot change the “desired location of the NPC while the path finder is calculating a different path. You have to cancel the current Future first.</p></div></div></div>
<div class="sect2"><h3 id="the-callable">The Callable</h3><div class="paragraph"><p>The next code sample shows the Callable that is dedicated to performing the long-running task (here, wayfinding). This is the task that used to block the rest of the application, and is now executed on a thread of its own. You implement the task in the Callable always in an inner method named <code>call()</code>.</p></div>
<div class="paragraph"><p>The task code in the Callable should be self-contained! It should not write or read any data of objects that are managed by the scene graph or OpenGL thread directly. Even reading locations of Spatials can be problematic! So ideally all data that is needed for the wayfinding process should be available to the new thread when it starts already, possibly in a cloned version so no concurrent access to the data happens.</p></div>
<div class="paragraph"><p>In reality, you might need access to the game state. If you must read or write a current state from the scene graph, you must have a clone of the data in your thread. There are only two ways:</p></div>
<div class="ulist"><ul><li><p>Use the execution queue <code>application.enqueue()</code> to create a sub-thread that clones the info. Only disadvantage is, it may be slower.<br>
The example below gets the <code>Vector3f location</code> from the scene object <code>mySpatial</code> using this way.</p></li><li><p>Create a separate World class that allows safe access to its data via synchronized methods to access the scene graph. Alternatively it can also internally use <code>application.enqueue()</code>.<br>
The following example gets the object <code>Data data = myWorld.getData();</code> using this way.</p></li></ul></div>
<div class="paragraph"><p>These two ways are thread-safe, they don&#8217;t mess up the game logic, and keep the Callable code readable.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// A self-contained time-intensive task:</span>
<span class="directive">private</span> <span class="predefined-type">Callable</span>&lt;MyWayList&gt; findWay = <span class="keyword">new</span> <span class="predefined-type">Callable</span>&lt;MyWayList&gt;(){
    <span class="directive">public</span> MyWayList call() <span class="directive">throws</span> <span class="exception">Exception</span> {

        <span class="comment">//Read or write data from the scene graph -- via the execution queue:</span>
        Vector3f location = application.enqueue(<span class="keyword">new</span> <span class="predefined-type">Callable</span>&lt;Vector3f&gt;() {
        <span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="directive">public</span> Vector3f call() <span class="directive">throws</span> <span class="exception">Exception</span> {
        <span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="comment">//we clone the location so we can use the variable safely on our thread</span>
        <span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="keyword">return</span> mySpatial.getLocalTranslation().clone();
        <span class="error"> </span><span class="error"> </span><span class="error"> </span><span class="error"> </span>}
        }).get();

        <span class="comment">// This world class allows safe access via synchronized methods</span>
        Data data = myWorld.getData();

        <span class="comment">//... Now process data and find the way ...</span>

        <span class="keyword">return</span> wayList;
    }
};</code></pre></div></div>
<div class="sect2"><h3 id="useful-links">Useful Links</h3><div class="paragraph"><p>High level description which describes how to manage the game state and the rendering in different threads:<br>
<a href="http://jahej.com/alt/2011_07_03_threading-and-your-game-loop.html">Threading and your game loop</a>.<br>
A C++ example can be found at:<br>
<a href="http://gamasutra.com/blogs/AndreaMagnorsky/20130527/193087/Multithreading_rendering_in_a_game_engine_with_CDouble_buffer_implementation.php">Multithreading-rendering in a game engine with CDouble buffer implementation</a>.</p></div></div>
<div class="sect2"><h3 id="conclusion">Conclusion</h3><div class="paragraph"><p>The cool thing about this approach is that every entity creates one self-contained Callable for the Executor, and they are all executed in parallel. In theory, you can have one thread per entity without changing anything else but the settings of the executor.</p></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2020-06-11 10:57:02 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>