<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><title>JME 3 Tutorial - Visualizing 3D Charts</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"><link rel="stylesheet" href="/home/travis/build/wmiksch/JMEWikiGerman/build/asciidoc/html5/jme3/tools/twemoji-awesome.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/wmiksch/JMEWikiGerman/edit/master/src/docs/asciidoc/jme3/tools/charts.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/wmiksch/JMEWikiGerman/new/master/src/docs/asciidoc/jme3/tools/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>JME 3 Tutorial - Visualizing 3D Charts</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version ,</span> <span id="revdate">2016/03/17 20:48</span></div><div id="toc" class="toc2"><div id="toctitle">Inhaltsverzeichnis</div><ul class="sectlevel1"><li><a href="#displaying-your-first-chart">Displaying your first chart</a></li><li><a href="#creating-your-heightmaps">Creating your heightmaps</a></li><li><a href="#what-s-all-this-talk-about-tiles">What&#8217;s all this talk about tiles?</a></li><li><a href="#creating-a-tile-tree">Creating a tile tree</a></li><li><a href="#drawing-the-mercator-grid">Drawing the Mercator Grid</a></li></ul></div></div><div id="content"><div id="preamble"><div class="sectionbody"><div class="paragraph"><p>Previous: <a href="../../jme3/tools/navigation.html">Navigation</a></p></div>
<div class="paragraph"><p>In this tutorial we will have a look at creating a simple 3D cartography application that allows you to display 3D charts at different zoom levels.</p></div>
<div class="paragraph"><p>This tutorial assumes that you know:</p></div>
<div class="ulist"><ul><li><p>About the <a href="../../jme3/tools/navigation.html">Navigation package</a>.</p></li><li><p>How to create a <a href="../../jme3/beginner/hello_terrain.html">3D landscape</a> using image-based heightmaps.</p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/tools/mercator_grid_3d_small.png" alt="mercator_grid_3d_small.png" width="" height=""></span></p></div>
<div class="paragraph"><p>You will learn that how to account for distortions that arise when mapping of one coordinate system into (i.e. when converting longitude/latitude into JME&#8217;s World Units), how to construct a tile tree and how to render a dynamic mercator grid.</p></div>
<div class="paragraph"><p><strong>This article was sponsored by <a href="http://planetmayo.com/">PlanetMayo Ltd</a></strong></p></div></div></div>
<div class="sect1"><h2 id="displaying-your-first-chart">Displaying your first chart</h2><div class="sectionbody"><div class="paragraph"><p>Let&#8217;s think about how we are going to get JME to display our terrain. The easiest way is to use JME&#8217;s`ImageBasedHeightMap`. Recall from the <a href="../../jme3/beginner/hello_terrain.html">Hello Terrain</a> tutorial that these are grayscale images which JME uses to create a terrain quad. So, in order to display a chart, we need an image of a (two-dimensional) mercator projection (such as the one depicted below), which we then load using:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">Texture heightMapImage = assetManager.loadTexture(DEFAULT_HEIGHTMAP);
heightmap = <span class="keyword">new</span> ImageBasedHeightMap(heightMapImage.getImage());
heightmap.load();
terrain = <span class="keyword">new</span> TerrainQuad(<span class="string"><span class="delimiter">&quot;</span><span class="content">terrain</span><span class="delimiter">&quot;</span></span>, <span class="integer">257</span>, TERRAIN_SIZE, heightmap.getHeightMap());
applyDefaultTexture();</code></pre></div></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/tools/globe.png" alt="A 256x256 mercator projection of planet earth." width="" height=""></span></p></div>
<div class="paragraph"><p>In essence, 3D chart visualization is achieved by converting the polygons composing planet earth&#8217;s landmass into float matrices whereby each value within the matrix represents a specific terrain height. For example, given a terrain of 100 x 100 world units, we construct a heightmap by creating a 100 x 100 matrix. Each cell within the matrix corresponds to a terrain coordinate; each cell’s value to that coordinate’s desired height. But you already knew that, so where&#8217;s the tricky part? Well, when visualizing a chart an accurate projection requires a translation of latitude/longitude coordinates into their equivalent world unit (x,y,z) counterparts. This translation however is not a straight forward mapping of one coordinate system into the other due to the distortion arising from projecting an oblate spheroid onto a flat surface (see my previous wiki article <a href="../../jme3/tools/navigation.html">here</a>). This means that if one would adhere to a linear scale, the Mercator projection would distort the size and shape of objects as the object distances itself from the equator, eventually resulting in infinite scaling as the pole is reached. So the first task at hand, is to construct accurate 2D projections of planet earth which we can then use as heightmaps. We can achieve this using the jme3.tools.navigation package and co-ordinate sets available at <a href="http://www.ngdc.noaa.gov/mgg/coast/">noaa.gov</a>.</p></div>
<div class="paragraph"><p>As <a href="../../jme3/tools/navigation.html">previously discussed</a>, the distortion in latitude is derived by using the difference in meridional parts between the chart’s centre and the current position as a baseline; through converting the difference to world units by dividing it by the number of world units contained within one minute, a latitude’s y-coordinate can be obtained. Calculating a position’s x-coordinate is somewhat easier as the distortion only applies to latitude, not longitude. Therefore x merely equals the sum or difference between itself and the viewport’s centre coordinate, depending on the relative location of the position itself and the chart’s centre. Despite being able to convert between the two coordinate systems, slight precision problems remain once the chart projection is scaled down past a level of 6 meters. This is caused by the pixel referencing system of modern displays being integer based; once the ratio of minutes to pixels exceeds the aforementioned threshold, slight inaccuracies are introduced into the display. However this is of little relevance to most GIS (such as Debrief) as a) the inaccuracies are a matter of meters (or even centimetres) and b) it is impossible to notice this variation as GPS exposes a much higher inaccuracy (between 10 - 100 meters).</p></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="fa icon-tip" title="Tip"></i></td><td class="content"><div class="paragraph"><p>To lessen the computational load, coordinate system conversion should only takes place when either the chart is re-centered or a change in scale / resolution is requested. Once converted, the coordinate sets are rendered to a buffer whose contents is then drawn for every UI update cycle.</p></div></td></tr></table></div>
<div class="paragraph"><p>.</p></div></div></div>
<div class="sect1"><h2 id="creating-your-heightmaps">Creating your heightmaps</h2><div class="sectionbody"><div class="paragraph"><p>There are two ways to create your heightmaps (also referred to as 'tiles' as each heightmap is a tile that composes our chart of the world). One is to use third-party software such as <a href="http://geotools.org/">GeoTools</a>. The other is to use the jme3.tools.navigation package to write a tile generator:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TileGenerator</span> {
    <span class="directive">private</span> <span class="type">int</span> lineCount;

    <span class="comment">/* List of polygons representing the countries that are to be drawn. */</span>
    <span class="directive">private</span> <span class="predefined-type">List</span>&lt;PositionContainer&gt; polygons;

    <span class="comment">/* The map projection used to generate the chart image. */</span>
    <span class="directive">private</span> MapModel2D map;

    <span class="comment">/* The chart's resolution in minutes of longitude per pixel. */</span>
    <span class="directive">private</span> <span class="type">double</span> mpp;

    <span class="comment">/* The chart's centre. */</span>
    <span class="directive">private</span> <span class="predefined-type">Position</span> centre;

    <span class="comment">/**
     * Constructs a new instance of TileGenerator.
     *
     * @param worldSize         The width of the chart for which tiles are to be
     *                          generated.
     * @since 1.0
     */</span>
    <span class="directive">public</span> TileGenerator(<span class="type">int</span> worldSize, <span class="type">double</span> mpp, <span class="predefined-type">Position</span> centre) {
        <span class="predefined-type">File</span> dataDirectory = <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">data</span><span class="delimiter">&quot;</span></span>);
        map = <span class="keyword">new</span> MapModel2D(worldSize);
        lineCount = <span class="integer">0</span>;
        <span class="predefined-type">File</span><span class="type">[]</span> files = dataDirectory.listFiles(<span class="keyword">new</span> <span class="predefined-type">FileFilter</span>() {

            <span class="directive">public</span> <span class="type">boolean</span> accept(<span class="predefined-type">File</span> pathname) {
                <span class="keyword">if</span> (pathname.toString().endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">.out</span><span class="delimiter">&quot;</span></span>)) {
                    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
                }
                <span class="keyword">return</span> <span class="predefined-constant">false</span>;
            }
        });
        loadChartData(files);
        <span class="local-variable">this</span>.mpp = mpp;
        <span class="local-variable">this</span>.centre = centre;
    }
    <span class="directive">public</span> <span class="type">void</span> createImageMap(<span class="type">int</span> worldSize) {
        map.setCentre(centre);
        map.calculateMinutesPerPixel(mpp);
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Generating chart with world width (in pixels): </span><span class="delimiter">&quot;</span></span> + worldSize);
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Generating chart with meters per pixel: </span><span class="delimiter">&quot;</span></span> + map.getMetersPerPixel());
        <span class="predefined-type">BufferedImage</span> img = <span class="keyword">new</span> <span class="predefined-type">BufferedImage</span>(worldSize,
                worldSize, <span class="predefined-type">BufferedImage</span>.TYPE_BYTE_GRAY);
        <span class="predefined-type">Graphics2D</span> g = img.createGraphics();
        <span class="predefined-type">Point</span> point1, point2;
        <span class="predefined-type">GeneralPath</span> polygonPath;
        g.setColor(<span class="predefined-type">Color</span>.WHITE);
        <span class="type">int</span> containerSize;

        <span class="keyword">for</span> (PositionContainer container : polygons) {
            polygonPath = <span class="keyword">new</span> <span class="predefined-type">GeneralPath</span>();
            containerSize = container.getPositions().size();
            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">1</span>; i &lt; containerSize; i++) {
                point1 = map.toPixel(container.getPositions().get(i));
                point2 = map.toPixel(container.getPositions().get(i - <span class="integer">1</span>));
                polygonPath.moveTo((<span class="type">double</span>) point1.getX(), (<span class="type">double</span>) point1.getY());
                polygonPath.lineTo((<span class="type">double</span>) point1.getX(), (<span class="type">double</span>) point1.getY());
                polygonPath.lineTo((<span class="type">double</span>) point2.getX(), (<span class="type">double</span>) point2.getY());
            }
            g.draw(polygonPath);
        }

        <span class="comment">// Write resulting image to file</span>
        <span class="keyword">try</span> {
            <span class="predefined-type">ImageIO</span>.write(img, <span class="string"><span class="delimiter">&quot;</span><span class="content">png</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">map.png</span><span class="delimiter">&quot;</span></span>));
        } <span class="keyword">catch</span> (<span class="exception">IOException</span> ioe) {
            ioe.printStackTrace();
        }
    }


    <span class="comment">/**
     * Draws depth contours.
     *
     * @param img           The image to draw to.
     * @param worldSize     The size of the chart.
     * @since 1.0
     */</span>
    <span class="directive">private</span> <span class="type">void</span> drawContours(<span class="predefined-type">BufferedImage</span> img, <span class="type">int</span> worldSize) {
        map.setCentre(centre);
        map.calculateMinutesPerPixel(mpp);
        <span class="predefined-type">BufferedImage</span> img2 = <span class="keyword">new</span> <span class="predefined-type">BufferedImage</span>(worldSize,
                worldSize, <span class="predefined-type">BufferedImage</span>.TYPE_BYTE_GRAY);
        <span class="predefined-type">Graphics2D</span> g = img2.createGraphics();
        g.drawImage(img, <span class="predefined-constant">null</span>, <span class="predefined-constant">null</span>);
        <span class="predefined-type">Point</span> point1, point2;
        <span class="predefined-type">GeneralPath</span> polygonPath;
<span class="comment">//        g.setColor(new Color(21, 21, 21));</span>
        g.setColor(<span class="predefined-type">Color</span>.WHITE);
        <span class="type">int</span> containerSize;

        <span class="keyword">for</span> (PositionContainer container : polygons) {
            polygonPath = <span class="keyword">new</span> <span class="predefined-type">GeneralPath</span>();
            containerSize = container.getPositions().size();
            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">1</span>; i &lt; containerSize; i++) {
                point1 = map.toPixel(container.getPositions().get(i));
                point2 = map.toPixel(container.getPositions().get(i - <span class="integer">1</span>));
                polygonPath.moveTo((<span class="type">double</span>) point1.getX(), (<span class="type">double</span>) point1.getY());
                polygonPath.lineTo((<span class="type">double</span>) point1.getX(), (<span class="type">double</span>) point1.getY());
                polygonPath.lineTo((<span class="type">double</span>) point2.getX(), (<span class="type">double</span>) point2.getY());
            }
            g.draw(polygonPath);
        }

        <span class="comment">// Write resulting image to file</span>
        <span class="keyword">try</span> {
            <span class="predefined-type">ImageIO</span>.write(img2, <span class="string"><span class="delimiter">&quot;</span><span class="content">png</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">map.png</span><span class="delimiter">&quot;</span></span>));
        } <span class="keyword">catch</span> (<span class="exception">IOException</span> ioe) {
            ioe.printStackTrace();
        }
    }

    <span class="comment">/**
     * Loads country border information from .out files, parses the information
     * and stores it as a PositionContainer which is later used to
     * produce the .png chart image.
     *
     * @param files             A List of files that contain
     *                          country border data.
     * @since 1.0
     */</span>
    <span class="directive">private</span> <span class="type">void</span> loadChartData(<span class="predefined-type">File</span><span class="type">[]</span> files) {
        <span class="predefined-type">Scanner</span> scan;
        PositionContainer countryBorderPosition;
        polygons = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;PositionContainer&gt;(<span class="integer">300</span>);
        <span class="predefined-type">String</span> tmp = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;
        <span class="predefined-type">String</span> tmpLat;
        <span class="predefined-type">String</span> tmpLong;
        <span class="predefined-type">StringTokenizer</span> stk;
        <span class="predefined-type">Position</span> pos;
        <span class="keyword">for</span> (<span class="predefined-type">File</span> file : files) {
            <span class="keyword">try</span> {
                scan = <span class="keyword">new</span> <span class="predefined-type">Scanner</span>(file);
                countryBorderPosition = <span class="keyword">new</span> PositionContainer();
                <span class="keyword">while</span> (scan.hasNext()) {
                    tmp = scan.nextLine();
                    <span class="keyword">if</span> (tmp.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="delimiter">&quot;</span></span>) || tmp.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">$</span><span class="delimiter">&quot;</span></span>) || tmp.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">;</span><span class="delimiter">&quot;</span></span>)) {
                        <span class="keyword">continue</span>;
                    }
                    <span class="keyword">if</span> (tmp.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">-1</span><span class="delimiter">&quot;</span></span>)) {
                        polygons.add(countryBorderPosition);
                        countryBorderPosition = <span class="keyword">new</span> PositionContainer();
                        <span class="keyword">continue</span>;
                    }
                    stk = <span class="keyword">new</span> <span class="predefined-type">StringTokenizer</span>(tmp, <span class="string"><span class="delimiter">&quot;</span><span class="content"> +</span><span class="delimiter">&quot;</span></span>);
                    <span class="keyword">while</span> (stk.hasMoreTokens()) {
                        tmpLat = stk.nextToken().trim();
                        <span class="keyword">if</span> (tmpLat.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">-1</span><span class="delimiter">&quot;</span></span>)) {
                            polygons.add(countryBorderPosition);
                            countryBorderPosition = <span class="keyword">new</span> PositionContainer();
                            <span class="keyword">continue</span>;
                        }
                        tmpLong = stk.nextToken().trim();
                        pos = <span class="keyword">new</span> <span class="predefined-type">Position</span>(<span class="predefined-type">Double</span>.parseDouble(tmpLat), <span class="predefined-type">Double</span>.parseDouble(tmpLong));
                        countryBorderPosition.add(pos);
                        lineCount++;
                    }
                }
            } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
                e.printStackTrace();
                <span class="predefined-type">System</span>.err.println(tmp);
            }
        }
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Debug 3D Tile Generator</span><span class="delimiter">&quot;</span></span>);
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">===========================</span><span class="delimiter">&quot;</span></span>);
        args = <span class="keyword">new</span> <span class="predefined-type">String</span>[<span class="integer">3</span>];
        args[<span class="integer">0</span>] = <span class="string"><span class="delimiter">&quot;</span><span class="content">1.2</span><span class="delimiter">&quot;</span></span>;
        args[<span class="integer">1</span>] = <span class="string"><span class="delimiter">&quot;</span><span class="content">51.8</span><span class="delimiter">&quot;</span></span>;
        args[<span class="integer">2</span>] = <span class="string"><span class="delimiter">&quot;</span><span class="content">-8.3</span><span class="delimiter">&quot;</span></span>;
        <span class="keyword">if</span> (args.length &lt; <span class="integer">3</span> || args.length &gt; <span class="integer">3</span>) {
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Incorrect argument usage. Should be mpp latitude longitude</span><span class="delimiter">&quot;</span></span>);
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Exiting</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span>;
        }
        <span class="predefined-type">String</span> mppStr = args[<span class="integer">0</span>];
        <span class="predefined-type">String</span> latitudeStr = args[<span class="integer">1</span>];
        <span class="predefined-type">String</span> longitudeStr = args[<span class="integer">2</span>];
        <span class="type">double</span> lon, lat, mpp;
        <span class="predefined-type">Position</span> centre;
        <span class="keyword">try</span> {
            mpp = <span class="predefined-type">Double</span>.parseDouble(mppStr);
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">MPP must be of type Double or Integer.</span><span class="delimiter">&quot;</span></span>);
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Exiting</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span>;
        }
        <span class="keyword">try</span> {
            lat = <span class="predefined-type">Double</span>.parseDouble(latitudeStr);
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Latitude must be of type Double or Integer.</span><span class="delimiter">&quot;</span></span>);
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Exiting</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span>;
        }
        <span class="keyword">try</span> {
            lon = <span class="predefined-type">Double</span>.parseDouble(longitudeStr);
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Longitude must be of type Double or Integer.</span><span class="delimiter">&quot;</span></span>);
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Exiting</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span>;
        }
        <span class="keyword">try</span> {
            centre = <span class="keyword">new</span> <span class="predefined-type">Position</span>(lat, lon);
        } <span class="keyword">catch</span> (InvalidPositionException ipe) {
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Invalid latitude or longitude coordinates.</span><span class="delimiter">&quot;</span></span>);
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Exiting</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span>;
        }
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Generating chart...Please wait...</span><span class="delimiter">&quot;</span></span>);
        TileGenerator generator = <span class="keyword">new</span> TileGenerator(TerrainViewer.TERRAIN_SIZE - <span class="integer">1</span>, mpp, centre);
        <span class="predefined-type">File</span> chart = <span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">map.png</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">if</span> (!chart.exists()) {
            generator.createImageMap(TerrainViewer.TERRAIN_SIZE - <span class="integer">1</span>);
        }
        <span class="keyword">try</span> {
            <span class="predefined-type">BufferedImage</span> img = <span class="predefined-type">ImageIO</span>.read(chart);
            generator.drawContours(img, TerrainViewer.TERRAIN_SIZE - <span class="integer">1</span>);

        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            e.printStackTrace();
        }
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Chart generated. Placed in file 'chart.png'. Exiting.</span><span class="delimiter">&quot;</span></span>);
    }
}</code></pre></div></div>
<div class="paragraph"><p>…where  .out file contains longitude / latitude coordinate pairs defining landmass contours. Here an extract:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code>51.79188150756147+-8.25435369629442
51.79184641740534+-8.254357553715453
51.79182071886024+-8.254353833180712
51.79181370477922+-8.254312317813477
51.79181369284153+-8.254267011113086
51.79182535405747+-8.254221642581026
51.79184870922772+-8.254183732747943
51.79188146269924+-8.254183530764353
51.79190724220316+-8.254221208836046
51.79190960635914+-8.254296874457655
51.79188150756147+-8.25435369629442
-1
51.79165344300885+-8.255042583168985
51.79161872648091+-8.255072177259352
51.79158175153456+-8.255082912194254
51.79156558301037+-8.255041382314799
51.79156556852833+-8.254985072910559
51.79158171385971+-8.254936452917438
51.79159555664058+-8.25487274689492
51.79161403682817+-8.254824070938184
51.79164411466118+-8.254798004805433
51.79168584436759+-8.254817161260844
51.79170675060084+-8.25487006519348
51.79169051462138+-8.254930145346941
51.79167197282713+-8.254993914789209
51.79165344300885+-8.255042583168985</code></pre></div></div>
<div class="paragraph"><p>(-1 acts as a separator, denoting the end of one polygon and the beginning of another).</p></div>
<div class="paragraph"><p>So what&#8217;s happening here? Well, we basically read the contents of all specified files, whereby each line is broken up into longitude/latitude pairs, converted into pixel (x,y) coordinates and used to construct a polygon which is added to a polygon container once a polygon separator is encountered. Once the object’s paint method is called, this polygon container is iterated and any polygons falling within the canvas (aka viewport) bounds are painted to the graphics context.
Essentially, this algorithm can be summarized as follows:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code>Constructor ( files ):
   for each file in files
      for each line in file
         if line == -1
            polygonList.add(polygon)
            new polygon
         else
            polygon.add(parse(line))

Paint ( graphics context ):
   for each polygon in polygonList
      if polygon inside view bounds
         graphics context.paint(polygon)</code></pre></div></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/tools/heightmap_modelling.png" alt="Summarizing process of visualizing a chart. From left to right: We draw the coordinates downloaded from noaa.gov. Ideally" width="" height=""></span>
<strong>Above:</strong> Summarizing process of visualizing a chart. From left to right: We draw the coordinates downloaded from noaa.gov. Ideally, each polygon should be filled in a light colour, whilst the surrounding ocean remains dark. JME uses these images to create an internal representation of the terrain (a float matrix).</p></div>
<div class="paragraph"><p>The heightmaps produced by the <code>TileGenerator</code> are essentially arrays containing float values ranging from 0 to 255. For convenience and efficiency, JME treats these arrays as Portable Network Graphic (PNG) images (again, see the Hello Terrain tutorial). This allows us to store each tile as an image, meaning that each tile will only need to be constructed once. Essentially what the tile generator therefore does is draw a greyscale image of each tile whereby dark colours (i.e. low values from 0 - 50) are valleys and high values (200 - 255) become mountains or hills. In order to maintain scale, these values are scaled by dividing the seabed’s maximum height (in meters) by the meters per pixel of the current chart.
With only a few specified points, JME interpolates the rest, making terrain construction using heightmaps more efficient than defining individual vertices for each pixel on the chart.
A tile’s texture is defined by its ”Alphamap”. This is a copy of its heightmap, but instead of defining height values, the floats composing the alphamap image define textures. For this purpose, a method known as ”texture splatting” is employed, whereby texture data is colour coded. That is, assuming that a spatial has two texture layers (let’s call them Tex1 and Tex2), each layer is associated with a colour: in the case of Debrief 3D, blue refers to a sand texture and red refers to dirt/grass textures. Although such an approach to texturing may sound confusing at first, it has the advantages that both heightmaps and alphamaps can be created in one go, and, as they are based on the same principle, can easily be modified in batch rather than individually.</p></div></div></div>
<div class="sect1"><h2 id="what-s-all-this-talk-about-tiles">What&#8217;s all this talk about tiles?</h2><div class="sectionbody"><div class="paragraph"><p>A tile tree is our way of keeping track of individual tiles. All that it is, is a set of nested sub-directories that holds charts. The top-level directory (our root) contains a chart of the entire world, and each sub-directory an enlarged area of our planet. For example, inside the root, we may have folders that contain a chart just for Ireland, the UK and France. As we traverse the tree further, we get the individual counties or provinces for each country. One way for us to represent this mess of directories, is via a <a href="http://en.wikipedia.org/wiki/Search_tree">Search Tree</a>.</p></div></div></div>
<div class="sect1"><h2 id="creating-a-tile-tree">Creating a tile tree</h2><div class="sectionbody"><div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">try</span> {
            <span class="predefined-type">File</span> resourceDirectory = <span class="keyword">new</span> <span class="predefined-type">File</span>(worldResourcesDirectory);
            <span class="keyword">if</span> (!resourceDirectory.isDirectory()) {
                <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Resource path must be a directory</span><span class="delimiter">&quot;</span></span>);
                <span class="predefined-type">System</span>.exit(<span class="integer">1</span>);
            }
            worldStructure = <span class="keyword">new</span> TileTree(resourceDirectory);
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            e.printStackTrace();
        }</code></pre></div></div>
<div class="paragraph"><p>Upon initialization, these tiles are read into memory by the <code>TileTree</code> object which treats, as the name suggests, the tiles composing the chart as a tree whereby the root node refers to the entire globe. Its children refer to sub-sections of the globe, and its children in turn to sub-sections of that sub-section. For example, the ”Ireland” node is a direct child of the root node. The ”Cork Harbour” node in turn is a direct child of the ”Ireland” node and represents an enlarged version of a sub-section of the Irish coast. Each such Node consists of a unique ID (used to identify the node), a list of child nodes, a path to the heightmap (tile) that it represents, the zoom level (referred to as the longitude level as the zoom is defined by minutes of longitude per pixel) and a latitude/longitude pair denoting the tile’s centre.</p></div>
<div class="paragraph"><p>Each heightmap is rendered depending on which ID the user selects (where each node in the tree is listed by its unique ID). As an ID is selected, the tree is traversed to find the node matching the given ID. The path to its heightmap is extracted and the heightmap is rendered by extracting the float array from the loaded image (that is, a texture object is created and loaded with the heightmap. A ImageBasedHeightMap object is then used to convert the heightmap and alphamap into corresponding height and texture arrays). → again, see JME tutorial on terrain.</p></div>
<div class="paragraph"><p>The Tile Tree’s contents is stored in assets/Heightmaps, and each directory level is composed of one descriptor file, one heightmap (in the form of a PNG image) and one alphamap (also in the form of a PNG image). The descriptor files end in a.desc filename extension and contain the geo-coordinate centre of the tile as well as the resolution of the node that they are representing (as always, the resolution is represented in minutes per pixel (mpp)). A descriptor file’s sole purpose is to allow the re-construction of the tile tree upon application initialization. Specifically, this is achieved by the ChartModel object which instantiates the TileTree, passing a reference to <em>assets/Heightmaps</em>, which <code>TileTree</code> then recursively scans, constructing the tree by interpreting the descriptor files. It is worth noting that all files per level should be named according to the heightmap tile that it represents. That is, if your level represents a chart of Ireland and your heightmap is named Ireland.png then your descriptor file should be named <em>Ireland.desc</em>, while your alphamap should be named <em>Ireland.png.Alphamap.png</em>.</p></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/tools/slide1.jpg" alt="The Tile Tree" width="" height=""></span>
<span class="image"><img src="../../jme3/tools/slide2.jpg" alt="Looking inside a node&#8230;&#8203;" width="" height=""></span>
<strong>Above:</strong> A look inside the “Ireland node. We can see the heightmap, descriptor file and alphamap.</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */</span>
<span class="keyword">package</span> <span class="namespace">util.datastructure</span>;

<span class="keyword">import</span> <span class="include">java.io.File</span>;
<span class="keyword">import</span> <span class="include">java.util.ArrayList</span>;
<span class="keyword">import</span> <span class="include">java.util.List</span>;
<span class="keyword">import</span> <span class="include">java.util.Scanner</span>;
<span class="keyword">import</span> <span class="include">jme3tools.navigation.Position</span>;

<span class="comment">/**
 * The TileTree handles the storage and retrieval of individual
 * charts. Each Node corresponds to one chart (a node's value being
 * the chart's absolute path. It's ID being the ID under which it is displayed).
 *
 * The tree reflects the application's chart directory structure, with the world
 * as its root and individual countries as its children. Sub-children of these nodes
 * represent &quot;close up&quot; version of each country / geographic sub areas of those countries.
 *
 * @author Benjamin Jakobus
 * @since 1.0
 * @version 1.0
 */</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">TileTree</span> {

    <span class="comment">/* The tree's root node. */</span>
    <span class="directive">private</span> Node root;

    <span class="comment">/**
     * Creates a new instance of TileTree. Nodes are generated
     * depending on the contents of the resource directory.
     *
     * @param resourceDirectory         The root of the application's resource
     *                                  directory (the resource directory being the
     *                                  directory in which all charts (aka Heightmaps)
     *                                  are being stored).
     * @since 1.0
     */</span>
    <span class="directive">public</span> TileTree(<span class="predefined-type">File</span> resourceDirectory) {
        <span class="predefined-type">File</span> directory = <span class="predefined-constant">null</span>;
        <span class="keyword">for</span> (<span class="predefined-type">File</span> f : resourceDirectory.listFiles()) {
            <span class="keyword">if</span> (f.isDirectory()) {
                directory = f;
                <span class="keyword">continue</span>;
            }
            <span class="keyword">if</span> (f.getName().endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">.desc</span><span class="delimiter">&quot;</span></span>)) {
                root = initNode(f);

            }
        }
        initTileTree(directory, root);
    }

    <span class="comment">/**
     * Initializes the tree's children. The root node should be initialized
     * prior to calling this method.
     *
     * @param resourceDirectory         The root of the application's resource
     *                                  directory (the resource directory being the
     *                                  directory in which all charts (aka Heightmaps)
     *                                  are being stored).
     * @param parentNode                The Node to which all
     *                                  subsequent nodes should be attached.
     * @since 1.0
     */</span>
    <span class="directive">private</span> <span class="type">void</span> initTileTree(<span class="predefined-type">File</span> resourceDirectory, Node parentNode) {
        <span class="predefined-type">File</span> directory = <span class="predefined-constant">null</span>;
        Node node = <span class="predefined-constant">null</span>;
        <span class="keyword">if</span> (parentNode == <span class="predefined-constant">null</span> || resourceDirectory == <span class="predefined-constant">null</span>) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">for</span> (<span class="predefined-type">File</span> f : resourceDirectory.listFiles()) {
            <span class="keyword">if</span> (f.isDirectory()) {
                directory = f;
                <span class="keyword">continue</span>;
            }
            <span class="keyword">if</span> (!f.getName().endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">.desc</span><span class="delimiter">&quot;</span></span>)) {
                <span class="keyword">continue</span>;
            } <span class="keyword">else</span> {
                node = initNode(f);
            }
        }
        parentNode.attachChild(node);
        node = parentNode;
        initTileTree(directory, parentNode);
    }

    <span class="comment">/**
     * Initializes an individual node depending on the contents of the descriptor
     * file (for information on descriptor files, refer to the software documentation).
     *
     * @param file                          The descriptor File with
     *                                      which to initialize the node's contents.
     * @return                              A new Node.
     * @since 1.0
     */</span>
    <span class="directive">private</span> Node initNode(<span class="predefined-type">File</span> file) {
        Node node = <span class="predefined-constant">null</span>;
        <span class="predefined-type">Scanner</span> scan;
        <span class="predefined-type">String</span> resourcePath = <span class="predefined-constant">null</span>;
        <span class="predefined-type">String</span> nodeID = <span class="predefined-constant">null</span>;
        <span class="predefined-type">String</span> longitudeLevel = <span class="predefined-constant">null</span>;
        <span class="predefined-type">Position</span> centre = <span class="predefined-constant">null</span>;
        <span class="type">int</span> currentLine = <span class="integer">0</span>;
        <span class="keyword">if</span> (file == <span class="predefined-constant">null</span>) {
            <span class="keyword">return</span> node;
        }
        <span class="keyword">try</span> {
            scan = <span class="keyword">new</span> <span class="predefined-type">Scanner</span>(file);
            resourcePath = file.getAbsolutePath().replace(<span class="string"><span class="delimiter">&quot;</span><span class="content">.desc</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">.png</span><span class="delimiter">&quot;</span></span>);
            resourcePath = resourcePath.substring(resourcePath.indexOf(<span class="string"><span class="delimiter">&quot;</span><span class="content">assets</span><span class="delimiter">&quot;</span></span>));
            nodeID =  file.getName().replace(<span class="string"><span class="delimiter">&quot;</span><span class="content">.desc</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>) + <span class="string"><span class="delimiter">&quot;</span><span class="content">_</span><span class="delimiter">&quot;</span></span> + file.getParentFile().getName();
            <span class="keyword">while</span> (scan.hasNextLine()) {
                <span class="keyword">if</span> (currentLine == <span class="integer">0</span>) {
                    <span class="predefined-type">String</span> tmp = scan.nextLine();
                    <span class="predefined-type">String</span><span class="type">[]</span> array = tmp.split(<span class="string"><span class="delimiter">&quot;</span><span class="char">\\</span><span class="content">+</span><span class="delimiter">&quot;</span></span>);
                    centre = <span class="keyword">new</span> <span class="predefined-type">Position</span>(<span class="predefined-type">Double</span>.parseDouble(array[<span class="integer">0</span>]),
                            <span class="predefined-type">Double</span>.parseDouble(array[<span class="integer">1</span>]));
                    currentLine++;
                } <span class="keyword">else</span> {
                    longitudeLevel = scan.nextLine().trim();
                }
            }
            node = <span class="keyword">new</span> Node(nodeID, resourcePath, longitudeLevel, centre);
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> e) {
            e.printStackTrace();
        }
        <span class="keyword">return</span> node;
    }

    <span class="comment">/**
     * Returns the Node matching the given ID.
     *
     * @param nodeID                The ID of the Node that you
     *                              wish to retrieve.
     * @return                      The Node matching the given ID.
     * @since 1.0
     */</span>
    <span class="directive">public</span> Node find(<span class="predefined-type">String</span> nodeID) {
        <span class="keyword">return</span> find(root, nodeID);
    }

    <span class="comment">/**
     * Returns the Node matching the given ID. This method is similar
     * to find() with the exception that it only begins searching from
     * a certain node downwards.
     *
     * @param nodeToSearch          The Node from which to start searching.
     * @param nodeID                The ID of the Node that you
     *                              wish to retrieve.
     * @return                      The Node matching the given ID.
     * @since 1.0
     */</span>
    <span class="directive">private</span> Node find(Node nodeToSearch, <span class="predefined-type">String</span> nodeID) {
        Node newNode = <span class="predefined-constant">null</span>;
        <span class="keyword">if</span> (nodeToSearch == <span class="predefined-constant">null</span>) {
            <span class="keyword">return</span> newNode;
        }
        <span class="keyword">if</span> (nodeToSearch.getNodeID().trim().compareTo(nodeID.trim()) == <span class="integer">0</span>) {
            <span class="keyword">return</span> nodeToSearch;
        } <span class="keyword">else</span> {
            <span class="keyword">for</span> (Node n : nodeToSearch.getChildren()) {
                newNode = find(n, nodeID);
                <span class="keyword">if</span> (newNode != <span class="predefined-constant">null</span>) {
                    <span class="keyword">return</span> newNode;
                }
            }
        }
        <span class="keyword">return</span> newNode;
    }

    <span class="comment">/**
     * Retrieves all nodes within the tree.
     *
     * @return                      A List of all nodes within the
     *                              tree.
     * @since 1.0
     */</span>
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;Node&gt; getNodes() {
        <span class="predefined-type">List</span>&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;Node&gt;();
        getNodes(root, nodes);
        <span class="keyword">return</span> nodes;
    }

    <span class="comment">/**
     * Returns all the children of a specific Node.
     *
     * @param node                  The Node whose children you want.
     * @param nodes                 The List to which to add these children.
     * @since 1.0
     */</span>
    <span class="directive">private</span> <span class="type">void</span> getNodes(Node node, <span class="predefined-type">List</span>&lt;Node&gt; nodes) {
        <span class="keyword">if</span> (node == <span class="predefined-constant">null</span>) {
            <span class="keyword">return</span>;
        }
        <span class="keyword">for</span> (Node n : node.getChildren()) {
            getNodes(n, nodes);
        }
        nodes.add(node);
    }
}</code></pre></div></div>
<div class="paragraph"><p>..and the Node:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">util.datastructure</span>;

<span class="keyword">import</span> <span class="include">java.util.ArrayList</span>;
<span class="keyword">import</span> <span class="include">java.util.List</span>;
<span class="keyword">import</span> <span class="include">jme3tools.navigation.Position</span>;

<span class="comment">/**
 * An individual node within the TileTree. Each Node
 * represents an individual tile (i.e. heightmap + alphamap).
 *
 * @author Benjamin Jakobus
 * @since 1.0
 * @version 1.0
 */</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Node</span> {
    <span class="comment">/* The node's unique identifier. */</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> nodeID;

    <span class="comment">/* Path to the resource that the node represents (aka the node's value). */</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> resource;

    <span class="comment">/* The node's children. */</span>
    <span class="directive">private</span> <span class="predefined-type">List</span>&lt;Node&gt; children;

    <span class="comment">/* The resolution (width in degrees of longitude) represented by this node.
     * i.e. the resolution of the chart that the node represents.
     */</span>
    <span class="directive">private</span> <span class="type">double</span> longitudeLevel;

    <span class="comment">/* The centre of the chart (aka tile) that the node represents. */</span>
    <span class="directive">private</span> <span class="predefined-type">Position</span> centre;

    <span class="comment">/**
     * Constructor.
     *
     * @param nodeID                The node's unique identifier.
     * @param resource              Path to the resource that the node represents
     *                              (aka the node's value).
     * @param longitudeLevel        The resolution (width in degrees of longitude)
     *                              represented by this node.
     * @param centre                The centre of the chart (aka tile) that the
     *                              node represents.
     * @since 1.0
     */</span>
    <span class="directive">public</span> Node(<span class="predefined-type">String</span> nodeID, <span class="predefined-type">String</span> resource, <span class="predefined-type">String</span> longitudeLevel, <span class="predefined-type">Position</span> centre) {
        <span class="local-variable">this</span>.nodeID = nodeID;
        <span class="local-variable">this</span>.resource = resource;
        <span class="local-variable">this</span>.longitudeLevel = <span class="predefined-type">Double</span>.parseDouble(longitudeLevel);
        <span class="local-variable">this</span>.centre = centre;
        children = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;Node&gt;();
    }

    <span class="comment">/**
     * Returns all of the node's children.
     *
     * @return          A List containing all of the node's children.
     * @since 1.0
     */</span>
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;Node&gt; getChildren() {
        <span class="keyword">return</span> children;
    }

    <span class="comment">/**
     * Returns the node's ID.
     *
     * @return          The node's unique identifier.
     * @since 1.0
     */</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getNodeID() {
        <span class="keyword">return</span> nodeID;
    }

    <span class="comment">/**
     * Returns the path to the tile that the node represents.
     *
     * @return          The path to the tile that the node represents.
     * @since 1.0
     */</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getResource() {
        <span class="keyword">return</span> resource;
    }

    <span class="comment">/**
     * Attaches a child to this node.
     *
     * @param child     The Node to attach.
     * @since 1.0
     */</span>
    <span class="directive">public</span> <span class="type">void</span> attachChild(Node child) {
        children.add(child);
    }

    <span class="comment">/**
     * Returns the width in degrees of longitude of the chart / resource that this
     * node represents.
     *
     * @return          the width in degrees of longitude of the chart / resource
     *                  that this node represents.
     * @since 1.0
     */</span>
    <span class="directive">public</span> <span class="type">double</span> getLongitudeLevel() {
        <span class="keyword">return</span> longitudeLevel;
    }

    <span class="comment">/**
     * The centre coordinate of the tile / chart that this node represents.
     *
     * @return          The chart's centre in terms of latitude / longitude.
     * @since 1.0
     */</span>
    <span class="directive">public</span> <span class="predefined-type">Position</span> getCentre() {
        <span class="keyword">return</span> centre;
    }
}</code></pre></div></div>
<div class="paragraph"><p>Loading a new chart is simple: all that we need to do is get the TileTree to find the chart for us (it&#8217;ll handle loading the descriptor file and just return a node):</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">Node node = tileTree.find(chartID);</code></pre></div></div>
<div class="paragraph"><p>We then use the returned node, to adjust our zoom-level:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">mapModel.calculateMinutesPerWorldUnit(node.getLongitudeLevel());
mapModel.setCentre(node.getCentre());</code></pre></div></div></div></div>
<div class="sect1"><h2 id="drawing-the-mercator-grid">Drawing the Mercator Grid</h2><div class="sectionbody"><div class="paragraph"><p>A mercator grid reflects the ”stretching” of the flat Mercator chart through the widening of the longitude / latitude lines. Using JME’s Mesh class, a 3D representation of the grid can be drawn procedurally (as opposed to pre-defining the mesh’s vertices using a 3D modelling tool such as Blender). This is achieved by defining a vector of positions, whereby each entry i within the vector denotes the starting point of a grid line, and i + 1 defining the line’s end-point. Next, the the order in which the mesh is constructed from these coordinates is defined. These are basically index pairs as the mesh consists of a set of lines, each having a start and end point. Finally, the coordinates vector and the indices are added to the mesh, which in turn is used to define the Geometry that is added to the scene graph:</p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> createGrid(<span class="type">double</span> longitudeLevel, <span class="type">float</span> increment) {
        granularity = increment;
        Mesh m = <span class="keyword">new</span> Mesh();
        m.setMode(Mesh.Mode.Lines);
        m.setLineWidth(<span class="float">1f</span>);

        <span class="type">float</span> max = (longitudeLevel &lt; <span class="integer">8</span> ? <span class="integer">2</span> : <span class="integer">85</span>);
        <span class="type">float</span> max2 = (longitudeLevel &lt; <span class="integer">8</span> ? <span class="integer">180</span> / <span class="integer">8</span> : <span class="integer">180</span>);
        Vector3f<span class="type">[]</span> positions = <span class="keyword">new</span> Vector3f[(<span class="type">int</span>) (<span class="predefined-type">Math</span>.ceil(max / increment) * <span class="integer">4</span>) + (<span class="type">int</span>) (<span class="predefined-type">Math</span>.ceil(max2 / increment) * <span class="integer">4</span>)];
        <span class="predefined-type">Position</span> pos;

        <span class="type">int</span> i = <span class="integer">0</span>;
        <span class="keyword">try</span> {
            <span class="comment">// Calculate initial spacings for the meridians and</span>
            <span class="comment">// parallels</span>


            <span class="comment">// Approach the grid construction from north to south and</span>
            <span class="comment">// east to west.</span>
            positions[<span class="integer">0</span>] = <span class="keyword">new</span> Vector3f(<span class="integer">0</span>, <span class="integer">0</span>, <span class="integer">0</span>);

            <span class="comment">// Latitude lines for northern hemisphere</span>
            <span class="keyword">for</span> (<span class="type">float</span> lat = <span class="integer">0</span>; lat &lt; max; lat += increment, i += <span class="integer">2</span>) {
                pos = <span class="keyword">new</span> <span class="predefined-type">Position</span>(lat, <span class="integer">180</span>);
                positions[i] = TerrainViewer.mapModel.toWorldUnit(<span class="keyword">new</span> <span class="predefined-type">Position</span>(lat, -<span class="integer">180</span>));
                positions[i + <span class="integer">1</span>] = TerrainViewer.mapModel.toWorldUnit(pos);
            }

            <span class="comment">// Latitude lines for southern hemisphere</span>
            <span class="keyword">for</span> (<span class="type">float</span> lat = <span class="integer">0</span>; lat &lt; max; lat += increment, i += <span class="integer">2</span>) {
                pos = <span class="keyword">new</span> <span class="predefined-type">Position</span>(lat * -<span class="integer">1</span>, <span class="integer">180</span>);
                positions[i] = TerrainViewer.mapModel.toWorldUnit(<span class="keyword">new</span> <span class="predefined-type">Position</span>(lat * -<span class="integer">1</span>, -<span class="integer">180</span>));
                positions[i + <span class="integer">1</span>] = TerrainViewer.mapModel.toWorldUnit(pos);
            }

            max = (longitudeLevel &lt; <span class="integer">8</span> ? <span class="integer">180</span> / <span class="integer">8</span> : <span class="integer">180</span>);
            <span class="comment">// Longitude lines for northern hemisphere</span>
            <span class="keyword">for</span> (<span class="type">float</span> lon = <span class="integer">0</span>; lon &lt; max; lon += increment, i += <span class="integer">2</span>) {
                pos = <span class="keyword">new</span> <span class="predefined-type">Position</span>(<span class="integer">85</span>, lon);
                positions[i] = TerrainViewer.mapModel.toWorldUnit(<span class="keyword">new</span> <span class="predefined-type">Position</span>(-<span class="integer">85</span>, lon));
                positions[i + <span class="integer">1</span>] = TerrainViewer.mapModel.toWorldUnit(pos);
            }

            <span class="comment">// Longitude lines for southern hemisphere</span>
            <span class="keyword">for</span> (<span class="type">float</span> lon = <span class="integer">0</span>; lon &lt; max; lon += increment, i += <span class="integer">2</span>) {
                pos = <span class="keyword">new</span> <span class="predefined-type">Position</span>(<span class="integer">85</span>, lon * -<span class="integer">1</span>);
                positions[i] = TerrainViewer.mapModel.toWorldUnit(<span class="keyword">new</span> <span class="predefined-type">Position</span>(-<span class="integer">85</span>, lon * -<span class="integer">1</span>));
                positions[i + <span class="integer">1</span>] = TerrainViewer.mapModel.toWorldUnit(pos);
            }
        } <span class="keyword">catch</span> (<span class="exception">Exception</span> ipe) {

        }

        <span class="type">int</span><span class="type">[]</span> indices = <span class="keyword">new</span> <span class="type">int</span>[i];
        <span class="type">int</span> v;
        <span class="keyword">for</span> (i = <span class="integer">0</span>, v = <span class="integer">0</span>; i &lt; indices.length; i += <span class="integer">2</span>, v++) {
            indices[i] = i;
            indices[i + <span class="integer">1</span>] = i + <span class="integer">1</span>;
        }

        m.setBuffer(<span class="predefined-type">Type</span>.Position, <span class="integer">3</span>, BufferUtils.createFloatBuffer(positions));

        m.setBuffer(<span class="predefined-type">Type</span>.Index, <span class="integer">1</span>, indices);
        m.updateBound();
        m.updateCounts();
        Material mat = <span class="keyword">new</span> Material(assetManager, <span class="string"><span class="delimiter">&quot;</span><span class="content">Common/MatDefs/Misc/Unshaded.j3md</span><span class="delimiter">&quot;</span></span>);
        mat.setColor(<span class="string"><span class="delimiter">&quot;</span><span class="content">m_Color</span><span class="delimiter">&quot;</span></span>, ColorRGBA.Gray);
        gridGeometry = <span class="keyword">new</span> Geometry(<span class="string"><span class="delimiter">&quot;</span><span class="content">Grid</span><span class="delimiter">&quot;</span></span>, m);
        gridGeometry.setMaterial(mat);
        Vector3f worldCentre = TerrainViewer.mapModel.getCentreWu();
        gridGeometry.setLocalTranslation(<span class="keyword">new</span> Vector3f(worldCentre.getX(),
                gridHeight, worldCentre.getZ()));
    }</code></pre></div></div>
<div class="paragraph"><p><span class="image"><img src="../../jme3/tools/screen_shot_2011-12-18_at_13.12.01.png" alt="screen_shot_2011-12-18_at_13.12.01.png" width="" height=""></span></p></div></div></div></div><div id="footer"><div id="footer-text">Version <br>Last updated 2020-05-23 13:25:31 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>