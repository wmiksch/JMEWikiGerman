<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.4"><title>3D Game Development Terminology</title><link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css"><link rel="stylesheet" href="/home/travis/build/wmiksch/JMEWikiGerman/build/asciidoc/html5/jme3/twemoji-awesome.css"></head><body class="article toc2 toc-left"><div id="header"><div id="toolbar"><a href="https://github.com/wmiksch/JMEWikiGerman/edit/master/src/docs/asciidoc/jme3/terminology.adoc"><i class="fa fa-pencil-square" aria-hidden="true"></i></a><a href="https://github.com/wmiksch/JMEWikiGerman/new/master/src/docs/asciidoc/jme3/"><i class="fa fa-plus-square" aria-hidden="true"></i></a><input dir="auto" style="position: relative; vertical-align: top;" spellcheck="false" autocomplete="off" class="searchbox__input aa-input" id="doc-search" name="search" placeholder="Search in the doc" required="required" type="search"></div><h1>3D Game Development Terminology</h1><div class="details"><span class="author" id="author"></span><br><span id="revnumber">version 2.0,</span> <span id="revdate">2-28-2020</span></div><div id="toc" class="toc2"><div id="toctitle">Inhaltsverzeichnis</div><ul class="sectlevel1"><li><a href="#3d-graphics-and-audio">3D Graphics and Audio</a></li><li><a href="#context-display-renderer">Context, Display, Renderer</a></li><li><a href="#geometry">Geometry</a><ul class="sectlevel2"><li><a href="#polygon-mesh-vertex">Polygon, Mesh, Vertex</a></li></ul></li><li><a href="#materials-color-lighting-shading">Materials: Color, Lighting/Shading</a><ul class="sectlevel2"><li><a href="#color">Color</a></li><li><a href="#light-sources">Light Sources</a></li><li><a href="#reflections">Reflections</a></li></ul></li><li><a href="#materials-textures">Materials: Textures</a><ul class="sectlevel2"><li><a href="#texture-mapping">Texture Mapping</a></li><li><a href="#environment-mapping">Environment Mapping</a></li><li><a href="#mip-map-texture">MIP Map Texture</a></li><li><a href="#procedural-textures">Procedural Textures</a></li><li><a href="#physically-based-rendering-textures-pbr">Physically Based Rendering Textures (PBR)</a></li></ul></li><li><a href="#animation">Animation</a><ul class="sectlevel2"><li><a href="#rigging-and-skinning">Rigging and Skinning</a></li><li><a href="#kinematics">Kinematics</a></li><li><a href="#controller-and-channel">Controller and Channel</a></li></ul></li><li><a href="#artificial-intelligence-ai">Artificial Intelligence (AI)</a></li><li><a href="#math">Math</a><ul class="sectlevel2"><li><a href="#coordinates">Coordinates</a></li><li><a href="#vectors">Vectors</a></li></ul></li><li><a href="#game-developer-jargon">Game Developer Jargon</a></li><li><a href="#3d-graphics-terminology-wiki-book">3D graphics Terminology Wiki book</a></li></ul></div></div><div id="content"><div id="preamble"><div class="sectionbody"><div class="paragraph"><p>Before you start, make certain you are familiar with the following concepts and terminology.</p></div></div></div>
<div class="sect1"><h2 id="3d-graphics-and-audio">3D Graphics and Audio</h2><div class="sectionbody"><div class="paragraph"><p><strong>OpenGL</strong> is the Open Graphics Library, a platform-independent specification for rendering 2D/3D computer graphics. For Java, there are two implementations of OpenGL-based renderers:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Lightweight Java Game Library (LWJGL).</p></li><li><p>Java OpenGL (JOGL)</p></li></ol></div>
<div class="paragraph"><p><strong>OpenAL</strong> is the Open Audio Library, a platform-independent 3D audio <abbr title="Application Programming Interface">API</abbr>.</p></div></div></div>
<div class="sect1"><h2 id="context-display-renderer">Context, Display, Renderer</h2><div class="sectionbody"><div class="paragraph"><p>The <strong>jME Context</strong> makes settings, renderer, timer, input and event listeners, display system, accessible to a JME game.</p></div>
<div class="ulist"><ul><li><p>The <strong>jME Display System</strong> is what draws the custom JME window (instead of Java Swing).</p></li><li><p>The <strong>Input System</strong> is the component that lets you respond to user input: Mouse clicks and movements, keyboard presses, and joystick motions.</p></li><li><p>The <strong>Renderer</strong> is what does all the work of calculating how to draw the 3D scenegraph to the 2D screen.</p><div class="ulist"><ul><li><p>The <strong>Shader</strong> is a programmable part of the rendering pipeline. The jME3 game engine uses it to offer advanced customizable materials.</p></li></ul></div></li></ul></div></div></div>
<div class="sect2"><h3 id="geometry">Geometry</h3><div class="sect2"><h3 id="polygon-mesh-vertex">Polygon, Mesh, Vertex</h3><div class="imageblock right"><div class="content"><img src="../jme3/dolphin-mesh.png" alt="Models (here a dolphin) are made up of polygon meshes" width="" height=""></div></div>
<div class="paragraph"><p>Most visible objects in a 3D scene are made up of polygon meshes – characters, terrains, buildings, etc. A mesh is a grid-like structure that represents a complex shape. The advantage of a mesh is that it is mathematically simple enough to render in real time, and detailed enough to be recognizable.</p></div>
<div class="paragraph"><p>Every shape is reduced to a number of connected polygons, usually triangles; even round surfaces such as spheres are reduced to a grid of triangles. The polygons' corner points are called vertices. Every vertex is positioned at a coordinate, all vertices together describe the outline of the shape.</p></div>
<div class="paragraph"><p>You create 3D meshes in tools called mesh editors, e.g in Blender. The jMonkeyEngine can load finished meshes (=models) and arrange them to scenes, but it cannot edit the mesh itself.</p></div></div></div>
<div class="sect2"><h3 id="materials-color-lighting-shading">Materials: Color, Lighting/Shading</h3><div class="paragraph"><p>What we call &#8220;color&#8221; is merely part of an object&#8217;s light reflection. The onlooker&#8217;s brain uses shading and reflecting properties to infer an object&#8217;s shape and material. Factors like these make all the difference between chalk vs milk, skin vs paper, water vs plastic, etc!</p></div>
<div class="sect2"><h3 id="color">Color</h3><div class="sect3"><h4 id="ambient-color">Ambient color</h4><div class="ulist"><ul><li><p>The uniform base color of the mesh – what it looks like when not influenced by any light source.</p></li><li><p>Usually similar to the Diffuse color.</p></li><li><p>This is the minimum color you need for an object to be visible.</p></li></ul></div></div>
<div class="sect3"><h4 id="diffuse-color">Diffuse color</h4><div class="ulist"><ul><li><p>The base color of the mesh plus shattered light and shadows that are caused by a light source.</p></li><li><p>Usually similar to the Ambient color.</p></li></ul></div></div></div>
<div class="sect2"><h3 id="light-sources">Light Sources</h3><div class="sect3"><h4 id="emissive-color">Emissive color</h4><div class="ulist"><ul><li><p>The color of light emitted by a light source or glowing material.</p></li><li><p>Only glowing materials such as lights have an emissive color, normal objects don&#8217;t have this property.</p></li><li><p>Often white (sun light).</p></li></ul></div></div></div>
<div class="sect2"><h3 id="reflections">Reflections</h3><div class="sect3"><h4 id="shininess">Shininess</h4><div class="ulist"><ul><li><p>Degree of shininess of a surface (1-128).</p></li><li><p>Shiny objects have small, clearly outlined specular highlights. (E.g. glass, water, silver)</p></li><li><p>Normal objects have wide, blurry specular highlights. (E.g. metal, plastic, stone, polished materials)</p></li><li><p>Uneven objects are not shiny and have no specular highlights. (E.g. cloth, paper, wood, snow)<br>
Set the Specular color to ColorRGBA.Black to switch off shininess.</p></li></ul></div></div>
<div class="sect3"><h4 id="specular-color">Specular Color</h4><div class="ulist"><ul><li><p>If the material is shiny, then the Specular Color is the color of the reflected highlights.</p></li><li><p>Usually the same as the emissive color of the light source (e.g. white).</p></li><li><p>You can use colors to achieve special specular effects, such as metallic or iridescent reflections.</p></li><li><p>Non-shiny objects have a black specular color.</p></li></ul></div>
<div style="text-align: center;" class="imageblock"><div class="content"><img src="../jme3/tanlglow2.png" alt="tanlglow2.png" width="400" height="234"></div></div></div></div></div>
<div class="sect2"><h3 id="materials-textures">Materials: Textures</h3><div class="paragraph"><p>Textures are part of Materials. In the simplest case, an object could have just one texture, the Color Map, loaded from one image file. When you think back of old computer games you&#8217;ll remember this looks quite plain.</p></div>
<div class="paragraph"><p>The more information you (the game designer) provide additionally to the Color Map, the higher the degree of detail and realism. Whether you want photo-realistic rendering or &#8220;toon&#8221; rendering (Cel Shading), everything depends on the quality of your materials and textures. Modern 3D graphics use several layers of information to describe one material, each mapped layer is a texture.</p></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="fa icon-tip" title="Tip"></i></td><td class="content"><div class="paragraph"><p>Got no textures? <a href="http://opengameart.org">Download free textures from opengameart.org</a>. Remember to keep the copyright notice together with the textures!</p></div></td></tr></table></div>
<div class="sect2"><h3 id="texture-mapping">Texture Mapping</h3><div class="imageblock right"><div class="content"><img src="https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Models/HoverTank/tank_diffuse.jpg" alt="tank_diffuse.jpg" width="128" height="128"></div></div>
<div class="ulist"><ul><li><p><strong>Color Map / Diffuse Map</strong></p><div class="ulist"><ul><li><p>A plain image file or a procedural texture that describes an object&#8217;s visible surface.</p></li><li><p>The image can have alpha channels for transparency.</p></li><li><p><strong>A Color Map is the minimum texture.</strong> You can map more textures as optional improvements.</p></li><li><p>Color Maps are unshaded. The same is called Diffuse Map in a Phong-illuminated material, because this texture defines the basic colors of light that are <em>diffused</em> by this object.</p></li></ul></div></li><li><p><strong>Bump Map</strong></p><div class="openblock"><div class="content"><div class="paragraph"><p>Bump maps are used to describe detailed shapes that would be too hard or simply too inefficient to sculpt in a mesh editor.</p></div>
<div class="paragraph"><p>There are two types:</p></div>
<div class="ulist"><ul><li><p>You use Normal Maps to model tiny details such as cracks in walls, rust, skin texture, or a canvas weave ( (<a href="http://en.wikipedia.org/wiki/Bump_mapping">More on BumpMaps</a>).</p></li><li><p>You use Height Maps to model large terrains with valleys and mountains.</p></li></ul></div></div></div>
<div class="imageblock right"><div class="content"><img src="../jme3/beginner/mountains512.png" alt="mountains512.png" width="128" height="128"></div></div></li><li><p><strong>Height Map</strong></p><div class="ulist"><ul><li><p>A height map is a grayscale image looking similar to a terrain map used in topography. Brighter grays represent higher areas and darker grays lower areas.</p></li><li><p>A heightmap can represent 256 height levels and is mostly used to roughly outline terrains.</p></li><li><p>You can draw a heightmap by hand in any image editor.</p></li></ul></div></li></ul></div>
<div class="imageblock right"><div class="content"><img src="https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Models/HoverTank/tank_normals.png" alt="tank_normals.png" width="128" height="128"></div></div>
<div class="ulist"><ul><li><p><strong>Normal Map</strong></p><div class="ulist"><ul><li><p>A well-done Normal Map makes a shape more detailed – without the need to add costly polygons to the mesh. It contains shading information that makes the object appear smoother and more fine-grained.</p></li><li><p>When you open a Normal Map in an image editor, it looks like a false-color version of the Color Map. Normal maps however are never used for coloring, instead, each the color values encode displacement data of bumps and cracks on the surface. Displacement data is represented by the Surface Normals of the slopes, hence the name.</p></li><li><p>You cannot draw or edit normal maps by hand, professional designers use software to calculate them off high-quality 3D models. You can either buy a professional texture set, or find free collections that include Normal Maps.</p></li></ul></div></li></ul></div>
<div class="imageblock right"><div class="content"><img src="https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Models/HoverTank/tank_specular.jpg" alt="tank_specular.jpg" width="128" height="128"></div></div>
<div class="ulist"><ul><li><p><strong>Specular Map</strong></p><div class="ulist"><ul><li><p>A Specular Map further improves the realism of an object&#8217;s surface: It contains extra information about shininess and makes the shape appear more realistically illumated.</p></li><li><p>Start out with a copy of the Diffuse Map in a medium gray that corresponds to the average shininess/dullness of this material. Then add ligher grays for smoother, shinier, more reflective areas; and darker grays for duller, rougher, worn-out areas. The resulting image file looks similar to a grayscale version of the Diffuse Map.</p></li><li><p>You can use colors in a Specular map to create certain reflective effects (fake iridiscence, metallic effect).</p></li></ul></div></li></ul></div>
<div class="imageblock right"><div class="content"><img src="https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Textures/Terrain/BrickWall/BrickWall.jpg" alt="BrickWall.jpg" width="128" height="128"></div></div>
<div class="ulist"><ul><li><p><strong>Seamless Tiled Textures</strong></p><div class="openblock"><div class="content"><div class="paragraph"><p>Tiles are a very simple, commonly used type of texture. When texturing a wide area (e.g. walls, floors), you don&#8217;t create one huge texture – instead you tile a small texture repeatedly to fill the area.</p></div>
<div class="paragraph"><p>A seamless texture is an image file that has been designed or modified so that it can be used as tiles: The right edge matches the left edge, and the top edge matches the bottom edge. The onlooker cannot easily tell where one starts and the next one ends, thus creating an illusion of a huge texture. The downside is that the tiling becomes painfully obvious when the area is viewed from a distance. Also you cannot use it on more complex models such as characters.</p></div>
<div class="paragraph"><p>See also this tutorial on <a href="http://www.photoshoptextures.com/texture-tutorials/seamless-textures.htm">How to make seamless textures in Photoshop</a>.</p></div></div></div></li></ul></div>
<div class="imageblock right"><div class="content"><img src="https://raw.githubusercontent.com/jMonkeyEngine/jmonkeyengine/master/jme3-testdata/src/main/resources/Models/Ferrari/Car.jpg" alt="Car.jpg" width="128" height="128"></div></div>
<div class="ulist"><ul><li><p><strong>UV Maps / Texture Atlas</strong></p><div class="openblock"><div class="content"><div class="paragraph"><p>Creating a texture for a cube is easy – but what about a character with a face and extremities? For more complex objects, you design the texture in the same ways as a flat sewing pattern: One image file contains the outline of the front, back, and side of the object, next to one another. Specific areas of the flat texture (UV coordinates) map onto certain areas of your 3D model (XYZ coordinates), hence the name UV map. Using UV Maps (also known as Texture Atlas), one model can have different textures on each side. You create one corresponding UV map for each texture.</p></div>
<div class="paragraph"><p>Getting the seams and mappings right is crucial: You must use a graphic tool like Blender to create UV Maps (Texture Atlas) and store the coordinates correctly. It&#8217;s worth the while to learn this, UV mapped models look a lot more professional.</p></div></div></div></li><li><p><strong>Albedo Maps</strong></p><div class="openblock"><div class="content"><div class="paragraph"><p>Albedo maps are similar to Diffuse maps with the exceptions that they don&#8217;t have shadows or highlights. They are used as the base color of a PBR material.</p></div></div></div></li></ul></div></div>
<div class="sect2"><h3 id="environment-mapping">Environment Mapping</h3><div class="imageblock right"><div class="content"><img src="../wp-uploads/glass-teapot1.png" alt="glass-teapot1.png" width="160" height="90"></div></div>
<div class="paragraph"><p>Environment Mapping or Reflection Mapping is used to create the impression of reflections and refractions in real time. It&#8217;s faster (but less accurate) than the raytracing methods used in offline rendering applications.</p></div>
<div class="paragraph"><p>You create a Cube Map to represent your environment; Sphere Maps are also possible, but often look distorted. Basically you give the environment map a set of images showing a &#8220;360°&#8221; view of the background scene – very similar to a skybox. The renderer maps the environment on the texture of the reflective surface, which results in an acceptable &#8220;glass/mirror/water&#8221; effect. Just like a skybox, the reflection map is static, so dynamic things (such as the player walking) are not part of the reflection. (!)</p></div>
<div class="paragraph"><p>See also: <a href="../jme3/advanced/water.html">Water</a>.</p></div></div>
<div class="sect2"><h3 id="mip-map-texture">MIP Map Texture</h3><div class="paragraph"><p>MIP Map means that you provide one texture in two or three resolutions in one file (MIP = &#8220;multum&#8221; in parvo = &#8220;many&#8221; in one). Depending on how close (or far) the camera is, the engine automatically renders a more (or less) detailed texture for the object. Thus objects look detailed at close up, but also look good when viewed from far away. Good for everything, but requires more time to create and more space to store textures. If you don&#8217;t provide custom ones, the jMonkeyEngine creates basic MIP maps automatically as an optimization.</p></div></div>
<div class="sect2"><h3 id="procedural-textures">Procedural Textures</h3><div class="paragraph"><p>A procedural texture is generated from repeating one small image, plus some pseudo-random, gradient variations (called Perlin noise). Procedural textures look more natural than static rectangular textures, and they look less distorted on spheres. On big meshes, their repetitiveness is much less noticable than with tiled seamless textures. Procedural textures are ideal for irregular large-area textures like grass, soil, rock, rust, and walls. Use the <a href="../sdk/neotexture.html">jMonkeyEngine SDK NeoTexture plugin</a> to create them.</p></div>
<div style="text-align: center;" class="imageblock"><div class="content"><img src="../wp-uploads/neotexture-2.jpg" alt="neotexture-2.jpg" width="380" height="189"></div></div>
<div class="paragraph"><p>See also: <a href="http://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/Every_Material_Known_to_Man">Blender: Every Material Known to Man</a></p></div></div>
<div class="sect2"><h3 id="physically-based-rendering-textures-pbr">Physically Based Rendering Textures (PBR)</h3><div class="quoteblock"><blockquote>Physically based rendering is an approach in computer graphics that seeks to render graphics in a way that more accurately models the flow of light in the real world.</blockquote><div class="attribution">&#8212; Wikipedia</div></div>
<div class="paragraph"><p>To simplify, PBR attempts to deliver photo realistic images based off the texture of a material and how light becomes more reflective the more you view it at an angle. In other words, it&#8217;s based on real physics. Everything has a reflection but accurately representing that reflection in video graphics has been mostly done with tricks prior to the introduction of PBR. Tricks as in using different lighting images (specular maps) overlaying color images (diffuse maps) to simulate shininess.</p></div>
<div class="paragraph"><p>With PBR, a materials &#8220;Metalness&#8221; (conductive) or "Dielectric" (insulator) and "Roughness" or lack thereof will determine how light gets reflected. For example, metal (Metalness) is smoother than dirt (dielectric) so has a higher reflection whereas the dirt would tend to absorb the light, just as in real world conditions.</p></div>
<div class="paragraph"><p>The technique described above is known as the &#8220;Metalness Workflow&#8221;. Where you are deciding whether the texture is metallic or dielectric and defining the amount of roughness for the texture.</p></div>
<div class="paragraph"><p>There is another workflow known as the &#8220;Specular Workflow&#8221;. In the metalness workflow the albedo map is used for both diffuse color and specular color. &#8220;Specular Workflow&#8221; uses a specular color map instead. In this workflow, the albedo map is the diffuse color, the specular map is the specular color, and you have a gray scale gloss map that is the same as the roughness map. The workflow is very similar to the old techniques used for making materials.</p></div>
<div class="paragraph"><p>This has been a brief introduction to PBR. In reality, it requires a significant amount of learning to implement correctly. Read the three part series of articles called, Physically Based Rendering, that can be found under the <a href="../jme3.html#materials-light-shadow">Materials, light, Shadow</a> topic for a more in depth explanation of PBR textures. This is a must read for any serious jME developer.</p></div>
<div class="paragraph"><p>See also: <a href="https://www.chaosgroup.com/blog/understanding-metalness">Understanding Metalness</a>.</p></div>
<div class="paragraph"><p>You should also conduct many searches on the subject, especially ones related to your modeling tool of choice.</p></div></div></div>
<div class="sect2"><h3 id="animation">Animation</h3><div class="paragraph"><p>In 3D games, Skeletal Animation is used for animated characters, but in principle the skeleton approach can be extended to any 3D mesh (for example, an opening crate&#8217;s hinge can be considered a primitive joint).</p></div>
<div class="paragraph"><p>Unless you animate a 3D cartoon, realism of animated characters is generally a problem: Movement can look alien-like mechanical or broken, the character appears hollow, or as if floating. Professional game designers invest a lot of effort to make characters animate in a natural way, including <a href="http://en.wikipedia.org/wiki/Motion_capture">motion capture</a>.</p></div>
<div class="sect2"><h3 id="rigging-and-skinning">Rigging and Skinning</h3><div class="imageblock right"><div class="content"><img src="../wp-uploads/blenderswordsman.png" alt="blenderswordsman.png" width="195" height="151"></div></div>
<div class="paragraph"><p>An animated character has an armature: An internal skeleton (Bones) and an external surface (Skin). The Skin is the visible outside of the character and it includes clothing. The Bones are not visible and are used to interpolate (calculate) the morphing steps of the skin.</p></div>
<div class="paragraph"><p>JME3, the game engine, only loads and plays your recorded animations. You must use a tool (such as Blender) to set up (rig, skin, and animate) a character.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p><strong>Rigging:</strong> The Construction of a character&#8217;s skeleton.</p><div class="ulist"><ul><li><p>Create as few Bones as possible to decrease complexity.</p></li><li><p>Bones are connected in a parent-child hierarchy: Moving one bone can pull another bone with it (e.g. arm pulls hand).</p></li><li><p>Bones follow a certain naming scheme so the 3D engines know what&#8217;s what.</p></li></ul></div></li><li><p><strong>Skinning:</strong> The association of individual bones with the corresponding skin sections.</p><div class="ulist"><ul><li><p>Each Bone is connected to a part of the Skin. Animating the (invisible) Bone pulls the (visible) Skin with it.<br>
E.g. the thigh Bone is connected to the upper leg Skin.</p></li><li><p>One part of the Skin can be affected by more than one bone (e.g. knee, elbow).</p></li><li><p>The connection between bones and skin sections is gradual: You assign weights how much each skin polygon is affected by any bone&#8217;s motion.<br>
E.g. when the thigh bone moves, the leg is fully affected, the hips joints less so, and the head not at all.</p></li><li><p>jMonkeyEngine supports hardware skinning (on the GPU, not on the CPU).</p></li></ul></div></li><li><p><strong>Keyframe Animation:</strong> A keyframe is one recorded snapshot of a motion sequence.</p><div class="ulist"><ul><li><p>A series of keyframes makes up one animation.</p></li><li><p>Each model can have several animations. Each animation has a name to identify it (e.g. &#8220;walk&#8221;, &#8220;attack&#8221;, &#8220;jump&#8221;).</p></li><li><p>You specify in your game code which keyframe animation to load, and when to play it.</p></li></ul></div></li></ol></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><i class="fa icon-tip" title="Tip"></i></td><td class="content"><div class="paragraph"><p>What is the difference between animation (rigging, skinning, keyframes) and transformation (rotation, scaling, moving, &#8220;slerp&#8221;)?</p></div>
<div class="ulist"><ul><li><p>Transformation is simpler than animation. Sometimes, transforming a geometry already makes it look like it is animated: For example, a spinning windmill, a pulsating alien ball of energy, moving rods of a machine. Transformations can be easily done with JME3 methods.</p></li><li><p>Animations however are more complex and are encoded in a special format (keyframes). They distort the skin of the mesh, and complex series of motions be &#8220;recorded&#8221; (in external tools) and played (in JME3).</p></li></ul></div></td></tr></table></div></div>
<div class="sect2"><h3 id="kinematics">Kinematics</h3><div class="ulist"><ul><li><p>Forward kinematics: &#8220;Given&#8221; the angles of all the character&#8217;s joints, what is the position of the character&#8217;s hand?</p></li><li><p>Inverse kinematics: &#8220;Given&#8221; the position of the character&#8217;s hand, what are the angles of all the character&#8217;s joints?</p></li></ul></div></div>
<div class="sect2"><h3 id="controller-and-channel">Controller and Channel</h3><div class="paragraph"><p>In the JME3 application, you register animated models to the Animation Controller. The controller object gives you access to the available animation sequences. The controller has several channels, each channel can run one animation sequence at a time. To run several sequences, you create several channels, and run them in parallel.</p></div></div></div>
<div class="sect1"><h2 id="artificial-intelligence-ai">Artificial Intelligence (AI)</h2><div class="sectionbody"><div class="paragraph"><p>Non-player (computer-controlled) characters (NPCs) are only fun in a game if they do not stupidly bump into walls, or blindly run into the line of fire. You want to make NPCs &#8220;aware&#8221; of their surroundings and let them make decisions based on the game state – otherwise the player can just ignore them. The most common use case is that you want to make enemies interact in a way so they offer a more interesting challenge for the player.</p></div>
<div class="paragraph"><p>&#8220;Smart&#8221; game elements are called artificially intelligent agents (AI agents). An AI agent can be used to implement enemy NPCs as well as trained pets; you also use them to create automatic alarm systems that lock doors and &#8220;call&#8221; the guards after the player triggers an intruder alert.</p></div>
<div class="paragraph"><p>The domain of artificial intelligence deals, among other things, with:</p></div>
<div class="ulist"><ul><li><p><strong>Knowledge</strong> – Knowledge is <em>the data</em> to which the AI agent has access, and on which the AI bases its decisions. Realistic agents only &#8220;know&#8221; what they &#8220;see and hear&#8221;. This implies that information can be hidden from the AI to keep the game fair. You can have an all-knowing AI, or you can let only some AI agents share information, or you let only AI agents who are close know the current state.<br>
Example: After the player trips the wire, only a few AI guards with two-way radios start moving towards the player&#8217;s position, while many other guards don&#8217;t suspect anything yet.</p></li><li><p><strong>Goal Planning</strong> – Planning is about how an AI agent <em>takes action</em>. Each agent has the priority to achieve a specific goal, to reach a future state. When programming, you split the agent&#8217;s goal into several subgoals. The agent consults its knowledge about the current state, chooses from available tactics and strategies, and prioritizes them. The agent repeatedly tests whether the current state is closer to its goal. If unsuccessful, the agent must discard the current tactics/strategy and try another one.<br>
Example: An agent searches the best path to reach the player base in a changing environment, avoiding traps. An agent chases the player with the goal of eliminating him. An agent hides from the player with the goal of murdering a VIP.</p></li><li><p><strong>Problem Solving</strong> – Problem solving is about how the agent <em>reacts to interruptions</em>, obstacles that stand between it and its goal. The agent uses a given set of facts and rules to deduct what state it is in – triggered by perceptions similar to pain, agony, boredom, or being trapped. In each state, only a specific subset of reactions makes sense. The actual reaction also depends on the agent&#8217;s, goal since the agent&#8217;s reaction must not block its own goal!<br>
Examples: If player approaches, does the agent attack or conceal himself or raise alarm? While agent is idle, does he lay traps or heal self or recharge magic runes? If danger to own life, does the agent try to escape or kamikaze?</p></li></ul></div>
<div class="paragraph"><p>More advanced AIs can also learn, for example using neural networks.</p></div>
<div class="paragraph"><p>There are lots of resources explaining interesting AI algorithms:</p></div>
<div class="ulist"><ul><li><p><a href="http://www.policyalmanac.org/games/aStarTutorial.htm">A* (A-Star) pathfinding for beginners</a></p></li><li><p><a href="http://theory.stanford.edu/~amitp/GameProgramming/">A* (A-star) pathfinding theory</a></p></li><li><p><a href="http://hem.fyristorg.com/dawnbringer/z-path.html">&quot;Z-Path&quot; algorithm</a> (backwards pathfinding)</p></li><li><p><a href="http://web.media.mit.edu/~jorkin/goap.html">GOAP&#8201;&#8212;&#8201;Goal-Oriented Action Planning</a></p></li><li><p><a href="http://neuroph.sourceforge.net/">Neuroph&#8201;&#8212;&#8201;Java Neural Networks</a></p></li></ul></div></div></div>
<div class="sect2"><h3 id="math">Math</h3><div class="imageblock right"><div class="content"><img src="../jme3/intermediate/coordinate-system.png" alt="coordinate-system.png" width="235" height="210"></div></div>
<div class="sect2"><h3 id="coordinates">Coordinates</h3><div class="paragraph"><p>Coordinates represent a location in a coordinate system. Coordinates are relative to the origin at (0,0,0). In 3D space, you need to specify three coordinate values to locate a point: X (right), Y (up), Z (towards you). Similarly, -X (left), -Y (down), -Z (away from you).
In contrast to a vector (which looks similar), a coordinate is a location, not a direction.</p></div>
<div class="sect3"><h4 id="the-origin">The Origin</h4><div class="paragraph"><p>The origin is the central point in the 3D world, where the three axes meet. It&#8217;s always at the coordinates (0,0,0).</p></div>
<div class="paragraph"><p><strong>Example:</strong> <code>Vector3f origin = new Vector3f( Vector3f.ZERO );</code></p></div></div></div>
<div class="sect2"><h3 id="vectors">Vectors</h3><div class="paragraph"><p>A vector has a length and a direction, like an arrow in 3D space. A vector starts at a coordinate (x1,y1,z1) or at the origin, and ends at the target coordinate (x2,y2,z2). Backwards directions are expressed with negative values.</p></div>
<div class="paragraph"><p><strong>Example:</strong></p></div>
<div class="listingblock"><div class="content"><pre class="CodeRay highlight"><code data-lang="java">Vector3f v = <span class="keyword">new</span> Vector3f( <span class="float">17f</span> , -<span class="float">4f</span> , <span class="float">0f</span> ); <span class="comment">// starts at (0/0/0)</span>
Vector3f v = <span class="keyword">new</span> Vector3f( <span class="float">8f</span> , <span class="float">0f</span> , <span class="float">33f</span> ).add(<span class="keyword">new</span> Vector3f( <span class="float">0f</span> , -<span class="float">2f</span> , -<span class="float">2f</span> )); <span class="comment">// starts at (8,-2,31)</span></code></pre></div></div>
<div class="sect3"><h4 id="unit-vectors">Unit Vectors</h4><div class="paragraph"><p>A <em>unit vector</em> is a basic vector with a length of 1 world unit. Since its length is fixed (and it thus can only point at one location anyway), the only interesting thing about this vector is its direction.</p></div>
<div class="ulist"><ul><li><p><code>Vector3f.UNIT_X</code>  = ( 1, 0, 0) = right</p></li><li><p><code>Vector3f.UNIT_Y</code>  = ( 0, 1, 0) = up</p></li><li><p><code>Vector3f.UNIT_Z</code>  = ( 0, 0, 1) = forwards</p></li><li><p><code>Vector3f.UNIT_XYZ</code> = 1 wu diagonal right-up-forewards</p></li></ul></div>
<div class="paragraph"><p>Negate the components of the vector to turn its direction, e.g. negating right (1,0,0) results in left (-1,0,0).</p></div></div>
<div class="sect3"><h4 id="normalized-vectors">Normalized Vectors</h4><div class="paragraph"><p>A <em>normalized vector</em> is a custom <em>unit vector</em>. A normalized vector is not the same as a <em>(surface) normal vector</em>.
When you normalize a vector, it still has the same direction, but you lose the information where the vector originally pointed.</p></div>
<div class="paragraph"><p><strong>Example:</strong> You normalize vectors before calculating angles.</p></div></div>
<div class="sect3"><h4 id="surface-normal-vectors">Surface Normal Vectors</h4><div class="imageblock right"><div class="content"><img src="../jme3/300px-surface_normal.png" alt="300px-surface_normal.png" width="" height=""></div></div>
<div class="paragraph"><p>A surface normal is a vector that is perpendicular (orthogonal) to a plane.
You calculate the Surface Normal by calculating the cross product.</p></div></div>
<div class="sect3"><h4 id="cross-product">Cross Product</h4><div class="paragraph"><p>The cross product is a calculation that you use to find a perpendicular vector (an orthogonal, a &#8220;right&#8221; angle at 90°).
In 3D space, speaking of an orthogonal only makes sense with respect to a plane. You need two vectors to uniquely define a plane. The cross product of the two vectors, <code>v1 × v2</code>, is a new vector that is perpendicular to this plane. A vector perpendicular to a plane is a called <em>Surface Normal</em>.</p></div>
<div class="paragraph"><p><strong>Example:</strong> The x unit vector and the y unit vector together define the x/y plane. The vector perpendicular to them is the z axis. JME can calculate that this equation is true:<br>
<code>( Vector3f.UNIT_X.cross( Vector3f.UNIT_Y ) ).equals( Vector3f.UNIT_Z )</code> == true</p></div></div>
<div class="sect3"><h4 id="transformation">Transformation</h4><div class="paragraph"><p>Transformation means rotating (turning), scaling (resizing), or translating (moving) objects in 3D scenes. 3D engines offer simple methods so you can write code that transforms nodes.</p></div>
<div class="paragraph"><p>Examples: Falling and rotating bricks in 3D Tetris.</p></div></div>
<div class="sect3"><h4 id="slerp">Slerp</h4><div class="paragraph"><p>Slerp is how we pronounce spherical linear interpolation when we are in a hurry. A slerp is an interpolated transformation that is used as a simple &#8220;animation&#8221; in 3D engines. You define a start and end state, and the slerp interpolates a constant-speed transition from one state to the other. You can play the motion, pause it at various percentages (values between 0.0 and 1.0), and play it backwards and forwards. <a href="https://javadoc.jmonkeyengine.org/v3.3.2-stable/com/jme3/math/Quaternion.html#slerp-com.jme3.math.Quaternion-com.jme3.math.Quaternion-float-">JavaDoc: slerp()</a></p></div>
<div class="paragraph"><p>Example: A burning meteorite Geometry slerps from &#8220;position p1, rotation r1, scale s1&#8221; in the sky down to &#8220;p2, r2, s2&#8221; into a crater.</p></div>
<div class="paragraph"><p><a href="../jme3/math.html">Learn more about 3D maths here.</a></p></div></div></div></div>
<div class="sect1"><h2 id="game-developer-jargon">Game Developer Jargon</h2><div class="sectionbody"><div class="ulist"><ul><li><p><a href="http://www.gamasutra.com/view/feature/6504/a_game_studio_culture_dictionary.php?print=1">A Game Studio Culture Dictionary</a></p></li></ul></div></div></div>
<div class="sect1"><h2 id="3d-graphics-terminology-wiki-book">3D graphics Terminology Wiki book</h2><div class="sectionbody"><div class="ulist"><ul><li><p><a href="http://en.wikipedia.org/wiki/User:Jreynaga/Books/3D_Graphics_Terms">http://en.wikipedia.org/wiki/User:Jreynaga/Books/3D_Graphics_Terms</a></p></li></ul></div></div></div></div><div id="footer"><div id="footer-text">Version 2.0<br>Last updated 2020-05-23 18:28:23 +00:00</div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script>docsearch({
  apiKey: 'a736b6d93de805e26ec2f49b55013fbd',
  indexName: 'jmonkeyengine',
  inputSelector: '#doc-search',
  debug: false // Set debug to true if you want to inspect the dropdown
});</script></body></html>